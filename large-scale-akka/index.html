<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Large scale Akka</title>
    <meta name="description" content="Monitoring Akka &amp; Play">
    <meta name="author" content="Jan Machacek, Alex Lashford">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-background="images/intro.jpg">
          <h1>Large scale Akka</h1>
          <h3>Architectures and approaches</h3>
          <p>
            <small>
              Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a>
            </small>
          </p>
          <p>
            <small><a href="http://www.eigengo.com/large-scale-akka">www.eigengo.com/large-scale-akka</a></small>
          </p>
        </section>

        <section data-background="images/intro.jpg">
          <h2>What are these large systems?</h2>
          <ul>
            <li>Are distributed across multiple nodes</li>
            <li>Need to be elastic</li>
            <li>Need to be responsive</li>
            <li>Need to be resilient</li>
          </ul>
          
          <aside class="notes">
            <p>One distributes the system because the entities it manages are too big to fit into one node, and to achieve resilience &amp; elasticity.</p>
            <p>Distribution unfortunately brings challenges when it comes to consistency, availability and partition tolerance.</p>
            <p>The biggest impediment for scale is shared mutable state (to be precise: contended access to shared mutable state). As soon as you have shared mutable state, you need to guard that state through a gateway of serial access, which means adding coordination and mutual exclusion, and that adds contention—services waiting in line for access the shared state. Contention is the biggest scalability killer.</p>
          </aside>
        </section>

        <section data-background="images/cthulhu.jpg">
          <h2>Shared mutable state</h2>
          <ul>
            <li>Contended shared mutable state model</li>
            <li>Non-contentded shared mutable state model</li>
            <li>Eventually-consistent, share-nothing model</li>
          </ul>
          <aside class="notes">
            <p>The biggest impediment for scale is shared mutable state (to be precise: contended access to shared mutable state). As soon as you have shared mutable state, you need to guard that state through a gateway of serial access, which means adding coordination and mutual exclusion, and that adds contention—services waiting in line for access the shared state. Contention is the biggest scalability killer.</p>

            <p>My advice would be to start off by trying to make your problem fit an eventually consistent, share-nothing design, with components communicating through asynchronous message-passing and in the few places where you need strong consistency then bite the bullet and pay the price. Then you will end up with an architecture that with very few bottlenecks, great scalability and elasticity characteristics and no single point of failure.</p>
          </aside>
        </section>

        <section data-background="images/cthulhu.jpg">
          <h2>CAP</h2>
          <ul>
            <li>Consistency</li>
            <li>Availability</li>
            <li>Partition tolerance</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>Consistency - A read is guaranteed to return the most recent write for a given client.</li>
              <li>Availability - A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout).</li>
              <li>Partition Tolerance - The system will continue to function when network partitions occur.</li>
            </ul>
            <p>Given that networks aren't completely reliable, you must tolerate partitions in a distributed system, period. Fortunately, though, you get to choose what to do when a partition does occur. According to the CAP theorem, this means we are left with two options: consistency and availability.</p>
            <ul>
              <li>CP: Atomic writes, but could bring timeouts</li>
              <li>AP: Return the latest thing a node is aware of, which may be stale</li>
            </ul>
            <p>A quiz—what is CA?—Think "traditional" RDBMSs</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Reactive applications are</h2>
          <ul>
            <li>Event-driven</li>
            <li>Elastic</li>
            <li>Resilient</li>
            <li>Responsive</li>
          </ul>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>It's not <em>just good architecture</em></h2>
          <aside class="notes">
            <p>The reactive manifesto describes new class of problems that a new class of applications throw at us. We are no longer in control of the inputs that our applications need to process. Think information from mobiles, wearables, and other devices that just keep arriving, and we have to process it. If this sounds too far-fetched, imagine building a new game (or even perhaps some analytics component of a game).</p>
            <p>And that ignores applications that are business-critical or process sensitive information. Imagine building a biometric surveillance system, which needs to detect dangerous intruders, and notify police / security. Data from the cameras are arriving all the time, and responses have to be sent out in every situation. It is unacceptable for such system to be unavailable.</p>
            <p>Unfortunately, I cannot say anything about real-time and life-critical systems!</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Event-driven</h2>
          <ul>
            <li>Events carry information between application's components</li>
            <li>Events do not change</li>
            <li>The event delivery is <em>asynchronous</em> and <em>non-blocking</em></li>
          </ul>
          <aside class="notes">
            <p>(1) Loose coupling between the components. Once an application is event-driven, it becomes
            easier to implement the remaining reactive traits.</p>
            <p>(2) Since the events are immutable, it is possible to persist them and replay them in case
            of system failures. This would not be possible if events were mutable.</p>
            <p>(3) There are many different asynchronous boundaries. Events represent mechanism to carry
            information accross these boundaries. The boundary could be
            <ul>
              <li>between CPU sockets</li>
              <li>between threads</li>
              <li>between network nodes</li>
            </ul>
            It is important to be able to cross this boundary as efficiently as possible. Unfortunately, crossing
            the boundary always involves cost: cache coherency, I/O waits, ...; therefore, it is important to make
            as much of the computing and I/O power available.</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Elastic</h2>
          <ul>
            <li>The ability to flex the number of components in the system according to demand</li>
            <li>The components can be single CPU cores, individual machines or clusters of machines</li>
          </ul>
          <aside class="notes">
            <p>(1) Remember, no language of framework is going to give you this for free.</p>
            <p>(2) To do this, one should be event-driven. If one is able to pass data across the asynchronous boundaries, then one is able to scale the systems by simply scheduling the execution of the messages on different CPUs. Additionally, in the actor concurrency model, an actor does not map to a single thread.</p>
            <p>(2) It is possible to scale by just replicating the same monolithic applications, but that may not be the most efficient use of the computing resources. And, running things on the cloud without using the machines fully is the most expensive hosting platform you'll ever have.</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Resilient</h2>
          <ul>
            <li>Ability to recover from errors at the appropriate level</li>
            <li>Ability to stop errors from spreading throughout the application</li>
          </ul>
          <aside class="notes">
            <p>(1) That does not mean being magically able to handle all exceptions. Recover here means to get back to 
            a stable state / state before the error ocurred.</p>
            <p>(1) The errors could be <em>a response that should have arrived in 1000 ms did not arrive</em>, the application should react at the appropriate level. Recall though that all message-passing is asynchronous, which "forces" us to think of the possible edge-cases from the outset.</p>
            <p>(2) Bulkheading is one such technique, where the application is divided into areas that are independent. Recall again how being event-driven makes this a lot easier.</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Responsive</h2>
          <ul>
            <li>Provide timely response even when dealing with failures</li>
            <li>Release the underlying OS primitives as soon as possible</li>
          </ul>
          <aside class="notes">
            <p>(1) This could be <em>I'm broken</em> delivered in place of the expected message, but delivered nonetheless. It is not acceptable to just hang, and not reply with anything at all.</p>
            <p>(2) Blocking threads is the source of non-responsiveness. And no, you cannot just arbitrarily increase the number of threads. Each thread is overhead in the kernel space; additionally, thread context switches represent cache coherency probkems, a blocking call might cause the CPU to enter sleep state, the OS might clear the FS caches, ...</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Frameworks &amp; tools</h2>
          <ul>
            <li>RxJava (JVM), Akka (JVM), <br/>Reactive Extensions (.NET)</li>
            <li>Erlang/OTP, Elixir/OTP (Beam)</li>
          </ul>
          <hr/>
          <ul>
            <li>core.async (JVM), <br/>Akka Streams (JVM)</li>
            <li>Asynchronous workflows (.NET)</li>
            <li>Async functions (ECMASCript 6)</li>
          </ul>
          <aside class="notes">
            <p>(1.1) Observable. Note that there is a <em>duality</em> between observable and iterable. You can think of observable as collection in time, and iterable as collection in space. In both cases, you can only go forward, and there may not be an upper bound on the number of values you will observe or iterate over.</p>
            <p>The manifesto does not prescribe any implementation. You are free to use the Haskell Rx extensions if you like. All that you have to do is to satisfy the four traits of the manifesto. I have slight beef with the fact that the manifesto does not include any TCK. Unlike, say, the reactive streams project, which also aims to be language-agnostic, but provides test compatiblity kit, allowing you to verify that your implementation satisfies the specification.</p>
          </aside>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Akka</h2>
          <ul>
            <li>Actor concurrency toolkit and runtime</li>
            <li>Akka isolates us from the mechanism of message passing and execution</li>
            <li>Actors handle messages</li>
            <li>Actors form hierarchies with parents supervising children</li>
          </ul>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Actors everywhere</h2>
          <pre><code data-trim class="scala">
class HelloWorldService extends Actor {

  def receive: Receive = {
    case request: HttpRequest =>
      val response = HttpResponse(...)
      sender ! response
  }

}
          </code></pre>          
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Actors everywhere</h2>
          <pre><code data-trim class="scala">
class HelloWorldServiceSpec 
  extends TestKit(ActorSystem())
  with SpecificationLike with ImplicitSender {
  val service = TestActorRef[HelloWorldService]

  "Any request" should {
    "Reply with Hello, world" in {
      service ! HttpRequest()
      expectMsgType[HttpResponse].entity 
        mustEqual HttpEntity("Hello, world")
    }
  }
}
          </code></pre>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Actors everywhere</h2>
          <pre><code data-trim class="scala">
object HelloWorld extends App {
  val system = ActorSystem()
  val service = 
    system.actorOf(Props[HelloWorldService])

  IO(Http)(system) ! Http.Bind(
    service, "0.0.0.0", port = 8080)

  Console.readLine()
  system.shutdown()
}          

class HelloWorldService extends Actor { ... }
          </code></pre>
        </section>

        <section data-background="images/intro.jpg">
          <h2>Expanding the world</h2>
          <ul>
            <li>Load-balanced instances of actor systems, each with its API</li>
            <li>A cluster of actor systems, each with its API</li>
          </ul>
          <aside class="notes">
            <p>In the first case, you have brushed away the [contended] shared mutable state to some DB. Multiple simple nodes that all connect to
            the same DB. Think of the scenario where one receives a write request, makes the updates, and replies with the changed state. Once the change hits the DB, all other nodes see that change on read. (T&amp;Cs applying, of course.) Nevertheless, it is very different from the clustered model.</p>
            <p>In the cluster model, we recognise the nature of distributed systems, and settle for weaker consistency models. A valid request will at some point be processed, but no shared mutable state escapes the application. </p>
          </aside>
        </section>

        <section data-background="images/blueprint.jpg">
          <h2>Terminology</h2>
          <ul>
            <li>Commands—inputs that needs validation, and may result in multiple events</li>
            <li>Events—validated commands that we <i>promise</i> to process</li>
            <li>Query—a "read command"</li>
          </ul>
        </section>

        <section data-background="images/blueprint.jpg">
          <img src="images/transient.png"/>
        </section>

        <section data-background="images/blueprint.jpg">
          <img src="images/es.png"/>
        </section>

        <section data-background="images/blueprint.jpg">
          <img src="images/cqrs-es.png"/>
        </section>

        <section data-background="images/blueprint.jpg">
          <img src="images/cluster.png"/>
        </section>

        <section data-background="images/football.jpg">
            <pre><code data-trim class="scala">
class MatchPlayer extends PersistentActor {
  import ShardRegion.Passivate
  context.setReceiveTimeout(45.minutes)

  var playerId: PlayerId = _
  var matchId: MatchId   = _
  var goals: List[Goal]  = _
  
  override val persistenceId: String = ???

  override def receiveCommand: Receive = ???
}
            </code></pre>
        </section>

        <section data-background="images/football.jpg">
<pre><code data-trim class="scala">
val playerMatchRegion: ActorRef = 
  ClusterSharding(system).start(
    typeName = "MatchPlayer",
    entryProps = Some(Props[MatchPlayer]),
    rememberEntries = false,
    idExtractor = idExtractor,
    shardResolver = shardResolver)
</code></pre>
        </section>

        <section data-background="images/football.jpg">
<pre><code data-trim class="scala">
val idExtractor: ShardRegion.IdExtractor = {
  case Score(p, m, g)    ⇒ (p + m, g)
  case stats@Stats(p, m) ⇒ (p + m, stats)
}
 
val shardResolver: ShardRegion.ShardResolver = 
  msg ⇒ msg match {
    case Score(p, m, g) ⇒ p + m
    case Stats(p, m)    ⇒ p + m
  }
</code></pre>
        </section>

        <section data-background="images/quidditch.jpg">
<pre><code data-trim class="scala">
val playerMatchRegion: ActorRef = 
  ClusterSharding(system).shardRegion("PlayerMatch")

playerMatchRegion ! 
  Score("Weasley", "Gryffindor v. Ravenclaw", Quaffle)
playerMatchRegion ! 
  Score("Weasley", "Gryffindor v. Ravenclaw", Quaffle)
playerMatchRegion ! 
  Score("Potter",  "Gryffindor v. Ravenclaw", Snitch)
</code></pre>
        </section>

        <section data-background="images/blueprint.jpg">
          <h2>Tooling</h2>
          <ul>
            <li>Scala</li>
            <li>Akka (including -persistence, -cluster, -streams, -persistence, -http)</li>
            <li>Spray</li>
            <li>Slick</li>
            <li>Shapeless, Scalaz</li>
            <li>Sbt</li>
          </ul>
        </section>

        <section data-background="images/ops.jpg">
          <h2>DevOps</h2>
          <ul>
            <li>Docker</li>
            <li>Mesos</li>
          </ul>
        </section>

        <section data-background="images/qa.jpg">
          <h2>Q&amp;A</h2>
        </section>
          
        <section data-background="images/devops.jpg">
          <h2>Thank you!</h2>
          <ul>
            <li>Slides at <a href="http://www.eigengo.com/large-scale-akka">www.eigengo.com/large-scale-akka</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a></li>
          </ul>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
