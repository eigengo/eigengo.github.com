<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>eigengo.com - Specs2 Spring</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">
        <header>
          <h1>Specs2 Spring</h1>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/eigengo/specs2-spring" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <p>The Specs2 Spring Extension includes code that will help you set up the context for the entire integration test—and by context, we mean the appropriate entries in the JNDI environment as well as the beans under test, autowired in to the instance of the test under execution. Finally, Specs2 Spring can be easily configured to run every example in its own transaction that rolls back automatically when the example completes.</p>
          <p>The extension is meant to help you write tests in Scala to test your Spring code (whether implemented in Java or Scala). You will be able to take advantage of all the features of the Specs2 framework and apply them to the Spring test code.</p>
          <p>Why bother, you ask? Because Specs2 and Scala allow you to be much more expressive in your tests. Consequently, your tests can focus on the essence of what is being tested, reducing the noise that the traditional Java code requires. A motivational example shows how to prepare test data, insert them to the RDBMS and then verify that some service method works as expected.</p>
          <pre class="brush:[scala]">
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.orm.hibernate3.HibernateTemplate
import org.specs2.spring.{BeanTables, HibernateDataAccess, Specification}
import org.hibernate.SessionFactory

@IntegrationTest
class SomeComponentSpec extends Specification
  with HibernateDataAccess with BeanTables {
  @Autowired var someComponent: SomeComponent = _
  @Autowired implicit var sessionFactory: SessionFactory = _ 

   * Shows the usage of BeanTables and HibernateDataAccess to
   * set up and insert test objects using the convenient tabular notation.
   */
  "getByUsername finds existing Rider" in {
    "age" | "username" | "name" | "teamName" |
      32  ! "janm"     ! "Jan"  ! "Wheelers" |
      30  ! "anic"     ! "Ani"  ! "Team GB"  |> insert[Rider]

    this.someComponent.getByUsername("janm").getName must_== ("Jan")
  } 
}
          </pre>
          <p>There are several things at play here: the custom <code>IntegrationTest</code> annotation defines the environment for the Spring components under test, the <code>Autowired</code> annotation on the <code>someComponent</code> variable tells Specs2 Spring to inject the constructed bean. Finally, the example sets up some test data using <code>BeanTables</code>, bulk-inserts them using the Hibernate ORM (method <code>insert[T]: (T => Result</code>) in HibernateDataAccess. Once the set-up work is done, we proceed to verify the correct behaviour of the getByUsername method in SomeComponent. Notably, the <code>“getByUsename finds existing Rider”</code>example runs in its own transaction. When the example completes (whether successfully or unsuccessfully), the transaction is rolled back!</p>
          <p>The equivalent Java code would be much, much longer: you would be able to use the spring-test artifact, giving you the ability to inject dependencies into your test and run the test methods in their own transactions. Unfortunately, you would still be left to your own devices to set up the JNDI environment (which is non-trivial and very repetitive work). Moreover, the body of the test method would contain much more noise, distracting you from the test code.</p>
          <p>Specs2 Spring contains support for:
            <ul>
              <li>Multiple XA DataSources to RDBMS as <code>javax.sql.DataSource</code>,</li>
              <li>Single XA transaction support as <code>javax.transaction.UserTransaction</code>,</li>
              <li>Multiple JMS queue and topic support <code>javax.jms.Queue</code>, <code>javax.jms.Topic</code>, <code>javax.jms.ConnectionFactory</code>,</li>
              <li>Multiple Javamail as <code>javax.mail.Session</code>,</li>
              <li>Multiple WorkManagers—both the <code>commonj.work.WorkManager</code> and the <code>javax.spi.resource.work.WorkManager</code>,</li>
              <li>Multiple arbitrary beans, as long as the types include accessible nullary constructor,</li>
              <li>Ability to register a class that can inject arbitrary entries into the JNDI environment.</li>
            </ul>
          </p>
        </section>

        <section id="resources">
          <a href="https://github.com/eigengo/specs2-spring/issues" id="view-on-github" class="button"><span>Issues</span></a>
        </section>

        <footer>
          Contact us at <a href="mailto:state@eigengo.com"><span>state@eigengo.com</span></a>
        </footer>

      </div>
    </div>
  </body>
</html>
