<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Reactive Manifesto in 15 minutes</title>
    <meta name="description" content="Monitoring Akka &amp; Play">
    <meta name="author" content="Jan Machacek, Alex Lashford">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-background="images/intro.png">
          <h1>Reactive Manifesto</h1>
          <h3>In 15 minutes</h3>
          <p>
            <small>
              Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a>
            </small>
          </p>
          <p>
            <small><a href="http://www.eigengo.com/reactive-manifesto-15">www.eigengo.com/reactive-manifesto-15</a></small>
          </p>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Reactive applications are</h2>
          <ul>
            <li>Event-driven</li>
            <li>Scalable</li>
            <li>Resilient</li>
            <li>Responsive</li>
          </ul>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>It's not <em>just good architecture</em></h2>
          <aside class="notes">
            <p>The reactive manifesto describes new class of problems that a new class of applications throw at us. We are no longer in control of the inputs that our applications need to process. Think information from mobiles, wearables, and other devices that just keep arriving, and we have to process it. If this sounds too far-fetched, imagine building a new game (or even perhaps some analytics component of a game).</p>
            <p>And that ignores applications that are business-critical or process sensitive information. Imagine building a biometric surveillance system (say hi to Andrew), which needs to detect dangerous intruders, and notify police / security. Data from the cameras are arriving all the time, and responses have to be sent out in every situation. It is unacceptable for such system to be unavailable.</p>
            <p>Unfortunately, I cannot say anything about real-time and life-critical systems!</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Event-driven</h2>
          <ul>
            <li>Events carry information between application's components</li>
            <li>Events do not change</li>
            <li>The event delivery is <em>asynchronous</em> and <em>non-blocking</em></li>
          </ul>
          <aside class="notes">
            <p>(1) Loose coupling between the components. Once an application is event-driven, it becomes
            easier to implement the remaining reactive traits.</p>
            <p>(2) Since the events are immutable, it is possible to persist them and replay them in case
            of system failures. This would not be possible if events were mutable.</p>
            <p>(3) There are many different asynchronous boundaries. Events represent mechanism to carry
            information accross these boundaries. The boundary could be
            <ul>
              <li>between CPU sockets</li>
              <li>between threads</li>
              <li>between network nodes</li>
            </ul>
            It is important to be able to cross this boundary as efficiently as possible. Unfortunately, crossing
            the boundary always involves cost: cache coherency, I/O waits, ...; therefore, it is important to make
            as much of the computing and I/O power available.</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Scalable</h2>
          <ul>
            <li>The ability to flex the number of components in the system according to demand</li>
            <li>The components can be single CPU cores, individual machines or clusters of machines</li>
          </ul>
          <aside class="notes">
            XXX
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Resilient</h2>
          <ul>
            <li>Ability to recover from errors at the appropriate level</li>
            <li>Ability to stop errors from spreading throughout the application</li>
          </ul>
          <aside class="notes">
            <p>(1) That does not mean being magically able to handle all exceptions. Recover here means to get back to 
            a stable state / state before the error ocurred.</p>
            <p>(1) The errors could be <em>a response that should have arrived in 1000 ms did not arrive</em>, the application should react at the appropriate level. Recall though that all message-passing is asynchronous, which "forces" us to think of the possible edge-cases from the outset.</p>
            <p>(2) Bulkheading is one such technique, where the application is divided into areas that are independent. Recall again how being event-driven makes this a lot easier.</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Responsive</h2>
          <ul>
            <li>Provide timely response even when dealing with failures</li>
            <li>XXX</li>
          </ul>
          <aside class="notes">
            <p>(1) This could be <em>I'm broken</em> delivered in place of the expected message, but delivered nonetheless. It is not acceptable to just hang, and not reply with anything at all.</p>
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Frameworks &amp; tools</h2>
          <ul>
            <li>RxJava (JVM), Akka (JVM), <br/>Reactive Extensions (.NET)</li>
            <li>Erlang/OTP, Elixir/OTP (Beam)</li>
          </ul>
          <hr/>
          <ul>
            <li>core.async (JVM), <br/>Akka Streams (JVM)</li>
            <li>Asynchronous workflows (.NET)</li>
            <li>Async functions (ECMASCript 7)</li>
          </ul>
          <aside class="notes">
            <p>(1.1) Observable. Note that there is a <em>duality</em> between observable and iterable. You can think of observable as collection in time, and iterable as collection in space. In both cases, you can only go forward, and there may not be an upper bound on the number of values you will observe or iterate over.</p>
            <p>The manifesto does not prescribe any implementation. You are free to use the Haskell Rx extensions if you like. All that you have to do is to satisfy the four traits of the manifesto. I have slight beef with the fact that the manifesto does not include any TCK. Unlike, say, the reactive streams project, which also aims to be language-agnostic, but provides test compatiblity kit, allowing you to verify that your implementation satisfies the specification.</p>
          </aside>
        </section>


        <section data-background="images/devops.jpg">
          <h2>Thank you!</h2>
          <ul>
            <li>Slides at <a href="http://www.eigengo.com/reactive-manifesto-15">www.eigengo.com/reactive-manifesto-15</a><br/>
            <small>(press <code>s</code> for speaker notes!)</small></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a></li>
          </ul>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
