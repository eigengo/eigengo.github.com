<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Functional programming in Finance and Healthcare</title>
    <meta name="description" content="FP Days 2014">
    <meta name="author" content="Jan Machacek, Andrew Sim">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>FP &amp; biometrics</h1>
          <p>In finance and healthcare</p>
          <p>
            <small>
              Andrew Sim <a href="https://twitter.com/andrewcsim">@andrewcsim</a><br/>
              Jan Machacek <a href="https://twitter.com/honzam399">@honzam399</a>
            </small>
          </p>
          <p>
            <small>
              <a href="http://www.cakesolutions.net/">Cake Solutions</a>
            </small>
          </p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

        <section>
          <img src="images/overall.png"/>
        </section>

        <section>
          <img src="images/server.png"/>
        </section>

        <section>
          <img src="images/cluster1.png"/>
        </section>

        <section>
          <img src="images/cluster2.png"/>
        </section>

        <section>
          <img src="images/natives.png"/>
        </section>

        <section>
          <img src="images/ios.png"/>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <img src="images/code.png"/>
          <p>All adding up to about 80,000 LoC</p>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <ul>
            <li>Scala</li>
            <li>JavaScript</li>
            <li>C++11, C++14</li>
            <li>Objective-C, Objective-C++</li>
            <li>Ruby</li>
          </ul>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <ul>
            <li>Scala ⇒ Akka, Spray, Scalaz</li>
            <li>JavaScript ⇒ AngularJS, jQuery</li>
            <li>C++11, C++14 ⇒ CUDA, OpenCV</li>
            <li>Objective-C, Objective-C++ ⇒ CoreImage, GPUImage</li>
            <li>Ruby ⇒ Ruby on Rails, Puppet</li>
          </ul>
        </section>

        <section>
          <h2>Tooling</h2>
          <ul>
            <li>SBT, cmake</li>
            <li>Jenkins</li>
            <li>Gatling</li>
            <li>Puppet</li>
          </ul>
        </section>

        <section>
          <h2>FP</h2>
          <h3>Impossible in 5 minutes, miracles in 8 hours</h3>
          <aside class="notes">
            <p>It's easy to start thinking that FP is the solution to all software development problems. As in, "take complicated system,
            sprinkle with FP and all is done." I accept that this is not always the case, but FP went a long way towards helping us 
            focus on the truly complex areas without having to worry about the mundane tasks.</p>
            <p>By mundane tasks I mean mechanical transformations of data—and I're sure you're now thinking <code>map</code>, <code>filter</code>,
            <code>flatMap</code>. This, together with immutable data structures was helped us in our reasoning about the system. Where possible,
            we stayed pure, avoiding side-effects in our functions.</p>
            <p>So, let's now see how we used FP in the bowels of the system.</p>
          </aside>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - code snippets</p>
          <p>Basic FP</p>
          <pre><code data-trim class="scala">
xs.map(f)
xs.foldLeft(0)(_ + _)
          </code></pre>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - code snippets</p>
          <p>Advanced FP: types</p>
          <pre><code data-trim class="scala">
type ReportT[B] = EitherT[Id, Throwable, B]
for {
  is ← load(input)
  r  ← foo(is)
} yield r
          </code></pre>
        </section>

        <section>
          <h2>FP doesn't solve all</h2>
          <aside class="notes">
            <p>Functional programming and strong types on their own have little to say or add to mutating concucrrent systems. We accept
            that FP generally favours immutability, which aids thinking about the state of the sytem. But consider our system:
            it recieves some input over the network, it does some processing, and sends the result potentially over some other
            network conneciton.</p>
            <p>So, our nice pure functional code that needs to run in a completely impure world. To make matters even worse,
            this impure world is concurrent, with many users making changes to the domain. Recall that our domain is 
            all users with all their faces, and all their transactions.</p>
            <p>I will shamelessly quote-mine Jonas Boner, who said that the biggest impediment to scalable systems is contended access 
            to shared mutable state. FP alone cannot fix that, we need some other approach that can help us. And in our case, this is 
            Akka—the toolkit and runtime for actor concurrency.</p>
          </aside>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - actor based concurrency</p>
          <p>API (chunk processing)</p>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - actor based concurrency</p>
          <p>FSM</p>
        </section>

        <section>
          <h2>FP and actors don't do mathematics and machine learning</h2>
          <aside class="notes">
            <p>It's all lost. FP is great in isolation, actors are OK, but when it comes to soving truly difficult stuff,
            it's back to mutable and imperative code, preferably in C++</p>
          </aside>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Natives</p>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Natives 2</p>
        </section>

        <section>
          <h2>Event-driven, elastic, resilient and responsive</h2>
          <aside class="notes">
            <p>Reactive</p>
            <p>That's why we use immutable messages, which we transform using "basic" FP—think <code>map</code>, <code>fold</code>,
            <code>flatMap</code> (that shit!). Being event-driven (using again immutable messages) helps us in achieving the remaining
            traits of reactive systems. It means that we find it easy to scale: all it takes is to add processing nodes, which communicate
            with each other using the messages. We achieve resilience by carefully structuring the components that form the application
            into hierarchies, where parents supervise their children. In other words, we handle errors at the right place, and by handle
            we naturally don't mean <code>try { ... } catch { case t: Throwable ...}</code>. Error handling is not about being able
            to recover from any exception, but to safely get to the state the system was in before the exception. This might involve
            restarting the failing actor, hierarchy of actors, or the JVM that hosts the actors. It's the same story for the native
            components. We do not attempt to recover from any old anything, when the component gets to a state that it cannot recover
            from, it <code>exit(-1)</code>s. Finally, we achieve responsiveness by using strictly non-blocking calls throughout
            the system.</p>
          </aside>
        </section>

        <section>
          <h2>No getting away from good engineering</h2>
          <aside class="notes">
            <p>Testing. Devops.</p>
          </aside>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

        <section>
          <h2>More applications</h2>
          <p></p>
        </section>

        <section>
          <h2>Thank you!</h2>
          <ul>
            <li>Other interesting work at <a href="http://www.cakesolutions.net">www.cakesolutions.net</a></li>
            <li>Slides at <a href="http://www.eigengo.com/fpdays-2014">www.eigengo.com/fpdays-2014</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a> | <a href="https://twitter.com/andrewcsim">@honzam399</a></li>
          </ul>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-stat../reveal.js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on ../reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>