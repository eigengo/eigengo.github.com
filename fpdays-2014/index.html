<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Functional programming in Finance and Healthcare</title>
    <meta name="description" content="FP Days 2014">
    <meta name="author" content="Jan Machacek, Andrew Sim">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>FP &amp; biometrics</h1>
          <p>In finance and healthcare</p>
          <p>
            <small>
              Andrew Sim <a href="https://twitter.com/andrewcsim">@andrewcsim</a><br/>
              Jan Machacek <a href="https://twitter.com/honzam399">@honzam399</a>
            </small>
          </p>
          <p>
            <small>
              <a href="http://www.cakesolutions.net/">Cake Solutions</a>
            </small>
          </p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>VeriSure</p>
          <p>InstaSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

        <section>
          <img src="images/overall.png"/>
        </section>

        <section>
          <img src="images/server.png"/>
        </section>

        <section>
          <img src="images/cluster1.png"/>
        </section>

        <section>
          <img src="images/cluster2.png"/>
        </section>

        <section>
          <img src="images/natives.png"/>
        </section>

        <section>
          <img src="images/ios.png"/>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <img src="images/code.png"/>
          <p>All adding up to about 80,000 LoC</p>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <ul>
            <li>Scala</li>
            <li>JavaScript</li>
            <li>C++11</li>
            <li>Objective-C++</li>
            <li>Ruby</li>
          </ul>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <ul>
            <li>Scala ⇒ Akka, Spray, Scalaz</li>
            <li>JavaScript ⇒ AngularJS, jQuery</li>
            <li>C++11 ⇒ CUDA, OpenCV</li>
            <li>Objective-C++ ⇒ CoreImage, GPUImage</li>
            <li>Ruby ⇒ Ruby on Rails, Puppet</li>
          </ul>
        </section>

        <section>
          <h2>FP</h2>
          <h3>Impossible in 5 minutes, miracles in 8 hours</h3>
          <aside class="notes">
            <p>It's easy to start thinking that FP is the solution to all software development problems. As in, "take complicated system,
            sprinkle with FP and all is done." I accept that this is not always the case, but FP went a long way towards helping us 
            focus on the truly complex areas without having to worry about the mundane tasks.</p>
            <p>By mundane tasks I mean mechanical transformations of data—and I're sure you're now thinking <code>map</code>, <code>filter</code>,
            <code>flatMap</code>. This, together with immutable data structures was helped us in our reasoning about the system. Where possible,
            we stayed pure, avoiding side-effects in our functions.</p>
            <p>So, let's now see how we used FP in the bowels of the system.</p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
GPUImageHoughTransformLineDetector *houghTransform = 
  [[GPUImageHoughTransformLineDetector alloc] init];
GPUImagePicture *gpuImage = 
  [[GPUImagePicture alloc] initWithCGImage:image];
[gpuImage addTarget:houghTransform];

[houghTransform setLinesDetectedBlock:
  ^(GLfloat* lineArray, NSUInteger linesDetected, 
    CMTime frameTime) {
    ...
  }];
  
[gpuImage processImage];
          </code></pre>
          <aside class="notes">
            <p>I will not bore you with the callback hell of JavaScript. Instead, I'll show you the pleasure of 
            Objective-C. (I would wholehartedly vote for Swift if I were starting the project today. Alas, Obj-C it is!)
            Here is an example of the image processing, applying the hough transform to the frames we receive from the camera.
            The FP snippet is, of course, the block <code>^(GLfloat* lineArray, NSUInteger linesDetected, CMTime frameTime)</code>.
            What you may also spot is that the GPUImage processing is asynchronous: that is, we supply the function (block in 
            Objective-C parlance), which contains the logic we want to perform, and only later on trigger the computation using
            <code>[gpuImage processImage]</code>.</p>
            <p>So, in addition to the comfortable concepts of FP, we need to be able to handle asynchronous and non-blocking code,
            together with the necessary synchronisation code between threads. This is just about doable in a small app running
            on the mobile, but it would be completely impossible to achieve on the server. But more on that later.</p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
typedef enum PVTestResult {
    Stop = 0,
    ContinueSucceed,
    ContinueFail
} PVTestResult;

typedef PVTestResult 
        (^AllImagesTest)(CGImageRef, CMTime, uint);

@interface PVTestCase : XCTestCase 
- (uint)allImagesIn:(PVTestSource *)source 
  inRealTime:(bool)rt must:(AllImagesTest)test;
@end
          </code></pre>
          <aside class="notes">
            <p>As good engineers, we of course thoroughly test our code. And we can bring back the FP concepts: here, 
            for example having a test that checks that all video frames in the given <code>source</code> (possibly played
            back in real time—that is frames that are not processed in time are skipped—must satisfy some <code>test</code></p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
- (void)testDocumentCapture {
  for (PVTestSource *source in ...) {
    [self allImagesIn:source inRealTime:true 
          must:^PVTestResult(CGImageRef frame, ...) {
      PVDocumentPreflightResult result = 
        [checker preflight:frame];
      if (result.pass) {
          PVAssertSameImage(frame, [source image]);
          return Stop;
      }
      return ContinueFail;
    }];
  }
}
          </code></pre>
          <aside class="notes">
            <p>Usage of our testing framework is quite trivial—though the most difficult task was to collect all the input data.
            We ended up with thousands of videos and images, collected during our testing phase. As you can expect—the test
            data set is constantly growing. And with it, test times, but that's a topic for a separate talk! We must press on.</p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <video data-autoplay src="videos/document.mp4"></video>
        </section>

        <section>
          <h2>Mobile</h2>
          <video data-autoplay src="videos/face.mp4"></video>
        </section>

        <section>
          <h2>Orchestration</h2>
          <pre><code data-trim class="scala">
type Authentication[A] = Either[Rejection, A]

def auth(users: ActorRef, headers: List[HttpHeader])
        (implicit ec: ExecutionContext): 
        Future[Authentication[Auth]] = headers
  .find(_.lowercaseName == "token")
  .flatMap { token ⇒
    (users ? token.value).mapTo[Auth].map(Right)
  }
  .getOrElse(Future(Left(AuthenticationFailed())))
          </code></pre>
        </section>

        <section>
          <h2>Orchestration</h2>
          <pre><code data-trim class="scala">
type ErrorMessage = String
sealed trait Err
case class ImageError(msg: ErrorMessage) extends Err
case class OcrError(msg: ErrorMessage) extends Err

def sharpen(image: ByteString): \/[ImageError, Image]
def ocr(image: ByteString): \/[OcrError, OcrResult]

for {
  sharper ← sharpen(image)
  ocred   ← ocr(sharper)
} yield ocred
          </code></pre>
        </section>

        <section>
          <h2>Orchestration</h2>
          <pre><code data-trim class="scala">
def runReportT(in: In, pe: Expression, 
               dse: DataSourceExpression): 
  EitherT[Id, Throwable, Array[Byte]] = {
  for {
    root  ← compileReport(in)
    pv    ← eval(pe)
    ps    =  toMap(parametersValues)
    dsv   ← eval(dse)
    ds    =  toDataSource(dsv)
    out   ← fromTryCatch[Id, Array[Byte]] { 
               runReportToPdf(root, ps, ds) 
             }
  } yield out
}          
          </code></pre>
        </section>

<!--
        <section>
          <h2>Orchestration</h2>
          <pre><code data-trim class="scala">
class pii extends StaticAnnotation {
  def macroTransform(annottees: Any*) = macro pii.impl
}

object pii {
  
  def impl(c: whitebox.Context)
          (annottees: c.Expr[Any]*): 
          c.Expr[Any] = {

    import c.universe._
    // check that PIIContext exists
    // add to every lower call
  }
  
}
          </code></pre>
        </section>
-->
        <section>
          <h2>FP alone doesn't solve all</h2>
          <aside class="notes">
            <p>Functional programming and strong types on their own have little to say or add to mutating concucrrent systems. We accept
            that FP generally favours immutability, which aids thinking about the state of the sytem. But consider our system:
            it recieves some input over the network, it does some processing, and sends the result potentially over some other
            network conneciton.</p>
            <p>So, our nice pure functional code that needs to run in a completely impure world. To make matters even worse,
            this impure world is concurrent, with many users making changes to the domain. Recall that our domain is 
            all users with all their faces, and all their transactions.</p>
            <p>I will shamelessly quote-mine Jonas Boner, who said that the biggest impediment to scalable systems is contended access 
            to shared mutable state. FP alone cannot fix that, we need some other approach that can help us. And in our case, this is 
            Akka—the toolkit and runtime for actor concurrency.</p>
          </aside>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
trait ImageStreamingService with Directives {
  this: Actor ⇒
  import context.dispatcher
  def streamingRoute(sess: ActorRef): Route = 
    path("process" / JavaUUID / "face") { id: UUID ⇒
      post {
        sender() ! RegisterChunkHandler(
          context.actorOf(Props(classOf[Handler], 
                                proc, id))))

        const(())
      }
    }
}
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
class Handler(sess: ActorRef, id: UUID) extends Actor {
  var buffer = ByteString()
  def receive = {
    case MessageChunk(data, _) ⇒
      buffer = buffer ++ data
      if (isComplete(buffer)) {
        buffer = ByteString.empty
        sess ! ProcessFace(id, buffer)
      }
    case ChunkedMessageEnd(_, _) ⇒
      sess ! End(id)
      context.stop(self)
  }
}
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object Session {
  case class StartSession(id: UUID, params: Params)
  case class ProcessFace(id: UUID, frame: ByteString)
  case class End(id: UUID)
}

class Session extends PersistentActor {
  var params: Params = _

  override val persistenceId: String = 
    s"session-${self.path.name}"
  override def receiveRecover: Receive = ...
  override def receiveCommand: Receive = ...
}
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object Session {
  case class StartSession(id: UUID, params: Params)
  case class ProcessFace(id: UUID, frame: ByteString)
  case class End(id: UUID)
  private case object SessionEnd

  val idExtractor: ShardRegion.IdExtractor = {
    case ProcessFace(id, f)  ⇒ (id.toString, f)
    case StartSession(id, p) ⇒ (id.toString, p)
    case EndFaceStep(id)     ⇒ ...
  }
}

class Session extends PersistentActor { ... }
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object Session {
  case class StartSession(id: UUID, params: Params)
  case class ProcessFace(id: UUID, frame: ByteString)
  case class End(id: UUID)
  private case object SessionEnd

  val idExtractor: ShardRegion.IdExtractor = ...
  val shardResolver: ShardRegion.ShardResolver = {
    case ProcessFace(id, _) ⇒ s"${id.hashCode() % 10}"
    ...
  }
}

class Session extends PersistentActor { ... }
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object Session { ... }
class Session extends PersistentActor { 
  var params: Params = _
  private def notRunning: Receive = {
    case cmd: Params ⇒ 
      persist(cmd) { evt ⇒ 
        params = evt
        context.become(running)
      }
  }
  private def running: Receive = ...

  override def receiveCommand: Receive = notRunning
}
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object Session { ... }
class Session extends PersistentActor { 
  var params: Params = _
  private def notRunning: Receive = ...
  private def running: Receive = {
    case cmd: ByteString      ⇒ // magic
    case cmd: FaceMatchResult ⇒
      persist(cmd)(const(()))
    case SessionEnd           ⇒ context.become(ended)
  }

  override def receiveCommand: Receive = notRunning
}
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object SessionView {
  case class State(params: Params, 
                   matches: Seq[FaceMatchResult])
  object State { val empty: State = ... }

  case class GetState(id: UUID)
  case object SessionGetState
}

class SessionView extends PersistentView { ... }
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object SessionView {
  ...
  val idExtractor: ShardRegion.IdExtractor = ...
  val shardResolver: ShardRegion.ShardResolver = ...
}

class SessionView extends PersistentView {
  val state: State = State.empty
  override val persistenceId = 
    s"session-${self.path.name}"
  override val viewId = 
    s"session-view-${self.path.name}"
  override def receive: Receive = ...
}
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
object SessionView { ... }

class SessionView extends PersistentView {
  val state: State = State.empty
  
  override def receive: Receive = {
    case p: Params if isPersistent ⇒
      state = state.withParams(p)
    case r: FaceMatchResult if isPersistent ⇒
      state = state.withFaceMatchResult(r)
    case SessionGetState ⇒
      sender() ! state
  }
}
          </code></pre>
        </section>

        <section>
          <h2>FP and actors don't do mathematics and machine learning</h2>
          <aside class="notes">
            <p>It's all lost. FP is great in isolation, actors are OK, but when it comes to soving truly difficult stuff,
            it's back to mutable and imperative code, in Objective-C++ or C++. </p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
float* buf = ...;
DSPSplitComplex res = { buf, buf + N/2 };
FFTSetup fftSetup = 
  vDSP_create_fftsetup(17, FFT_RADIX2);
vDSP_fft2d_zrip(fftSetup, 
  &amp;res, 1, 0, 
  Log2C, Log2R, 
  kFFTDirection_Forward);
          </code></pre>
          <aside class="notes">
            <p>In portions of our system it was necessary to leave the comforts of FP behind, and drop down to the unpleasantness 
            of unmanaged pointers, strange memory layouts, and whatever else the hardware needs. In this particular case, 
            we're using the iPhone's DSP to process portions of the image, and this approach gave us more than 5 x improvement 
            in processing speed, and much lower power consumption. Did I mention that DSP programming is cool? No? Well, it is!</p>
          </aside>
        </section>

        <section>
          <h2>Server-side image processing</h2>
          <pre><code data-trim class="cpp">
class FaceVerify {
public:
  FaceVerify(CoreShared &amp;c, PreCalcWavShared &amp;w);
  Encoding encodeImage(Image &amp;image, std::string ...);
private:
  bool calcJets(PixGrid &amp;PG);
};

class CoreShared {
public:
  CoreShared();
private:
  class WaveletGrid { ... };
  WaveletGrid m_WG[MAX_WAVELET_GRIDS];

  cvm::rmatrix **m_pmDataT;
  cvm::rmatrix **m_pmCoeffVectsSigT;
};
          </code></pre>
          <aside class="notes">
            <p>What can I add? We—and this is royal we now—had to abandon all hope of comfortable programming, garbage collectors and
            other such creature comforts, and get our hands dirty. In this particular snippet—and I promise I won't go into any further
            details, for you know what I'd have to do if I told you all the secrets—we have the code that processes encodes the incoming
            image of a face into an <code>Encoding</code>: our biometric faceprint. We can then compare two encodings to ultimately compute
            confidence level that the faces are of the same person. The confidence computation is a weighing of acceptable false acceptance
            and false rejection rate. One would like to have both rates 0; unfortunately, both rates are opposite ends of a scale. As one
            decreases false acceptance rate, false rejection rate rises. The secret ingredient is to realise that biometrics should be one
            of many instruments to verify the user's identity... but I digress. Let's get back to FP.</p>
          </aside>
        </section>

        <section>
          <h2>Server-side image processing</h2>
          <pre><code data-trim class="cpp">
class Main : public RabbitRpcServer {
public:
  Main(const std::string queue, ...);
  virtual ~Main();
protected:
  virtual std::string handleMessage(
    const AmqpClient::BasicMessage::ptr_t message, 
    const AmqpClient::Channel::ptr_t channel);
}
          </code></pre>
          <aside class="notes">
            <p>Regardless of how far away we left the world of FP in an individual component, our aim was to build the system as a 
            collection of independent and well-defined components with clear communication mechanism between them. And so, all of this 
            rather complex code—with all its tests and training programs that we're not even showing here—are wrapped in code that 
            ultimately receives a message and replies back to the sender asynchronously. The sender never blocks waiting for a response.</p>
            <!--
            <p>In real world, imagine writing your request on a piece of paper, placing it in an envelope together with an envelope for 
            the response with a one-time-only mailbox.
            The recipient should do whatever you ask him to do, and then simply place the response in the envelope you provided, and without 
            thinking simply post it back. When the response arrives into the mailbox, you immediately know which response it is from. You then
            remove the mailbox</p>
            -->

            <p>This follows the same pattern as the Actor-based code in Scala, which made it so much easier for us to construct the entire
            system... A system that is</p>
          </aside>
        </section>

        <section>
          <h2>Event-driven, elastic, resilient and responsive</h2>
          <aside class="notes">
            <p>Reactive</p>
            <p>That's why we use immutable messages, which we transform using "basic" FP—think <code>map</code>, <code>fold</code>,
            <code>flatMap</code> (that shit!). Being event-driven (using again immutable messages) helps us in achieving the remaining
            traits of reactive systems. It means that we find it easy to scale: all it takes is to add processing nodes, which communicate
            with each other using the messages. We achieve resilience by carefully structuring the components that form the application
            into hierarchies, where parents supervise their children. In other words, we handle errors at the right place, and by handle
            we naturally don't mean <code>try { ... } catch { case t: Throwable ...}</code>. Error handling is not about being able
            to recover from any exception, but to safely get to the state the system was in before the exception. This might involve
            restarting the failing actor, hierarchy of actors, or the JVM that hosts the actors. It's the same story for the native
            components. We do not attempt to recover from any old anything, when the component gets to a state that it cannot recover
            from, it <code>exit(-1)</code>s. Finally, we achieve responsiveness by using strictly non-blocking calls throughout
            the system.</p>
          </aside>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

        <section>
          <h2>No getting away from good engineering</h2>
          <aside class="notes">
            <p>Good testing is absolute must. I cannot stress just how important it is be certain that your code works as you expect.
            Strongly typed FP is certainly a good start, but—at least in the form available in Scala, C++, Ruby et al—is far from
            being able to say anything about correctness of your software. The simple fact that you can have side-effects without
            any kind of checks should be worrying!</p>
          </aside>
        </section>

        <section>
          <h2>No getting away from humans</h2>
          <aside class="notes">
            <p>And their horrible, horrible faces. There were so many times I've seen the nostrils of our users when we
            were running the initial testing... It now replaces the whale in my nightmares!</p>
            <p>But what I actually mean are humans on your engineering teams: they have to be ready to take on the challenges
            of FP, types, distributed systems with open mind and their thinking hats firmly on. My general take on the subject
            is that difficult systems are difficult to implement regardless of the language. The task is to make as much of
            the codebase as easy to express and understand and possible. And our experience with FP was certainly that it goes
            a long way to highlighting the essence of the task. Anecdotally, just how much harder do you think it is to understand the 
            details of <code>AbstractSingletonProxyFactoryBean</code> compared to <code>EitherT[F[_], A, B]</code>?</p>
            <p>The next challenge is to be able to demonstrate to your business (be it internal development or your customers) that
            you have selected a mature technology, that you're not just playing around with cool stuff! My experience is that 
            today's functional languages are certainly well-accepted in the wild. The ecosystem—the tooling, libraries and frameworks—
            has also matured. The days of having to sellotape together the old &amp; the new are gone.</p>
            <p>Finally, one can use FP to attact talent... With that in mind, if you're looking for your next challenge at Cake Solutions,
            get in touch!</p>
          </aside>
        </section>

<!--
        <section>
          <h2>No getting away from good engineering</h2>
          <pre><code data-trim class="scala">
val image: ByteString = ...
def launchNuclearMissiles(failsafe: Byte): Unit = {
  if (System.currentTimeMillis() % failsafe == 0) {
    Silos.launch()
  }
}

image.foreach(launchNuclearMissiles)
          </code></pre>
          <aside class="notes">
            <p>!!!</p>
          </aside>
        </section>
-->

        <section>
          <h2>Thank you!</h2>
          <ul>
            <li>Other interesting work at <a href="http://www.cakesolutions.net">www.cakesolutions.net</a></li>
            <li>Slides at <a href="http://www.eigengo.com/fpdays-2014">www.eigengo.com/fpdays-2014</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a> | <a href="https://twitter.com/andrewcsim">@andrewcsim</a></li>
          </ul>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-stat../reveal.js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on ../reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>