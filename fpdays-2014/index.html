<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Functional programming in Finance and Healthcare</title>
    <meta name="description" content="FP Days 2014">
    <meta name="author" content="Jan Machacek, Andrew Sim">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>FP &amp; biometrics</h1>
          <p>In finance and healthcare</p>
          <p>
            <small>
              Andrew Sim <a href="https://twitter.com/andrewcsim">@andrewcsim</a><br/>
              Jan Machacek <a href="https://twitter.com/honzam399">@honzam399</a>
            </small>
          </p>
          <p>
            <small>
              <a href="http://www.cakesolutions.net/">Cake Solutions</a>
            </small>
          </p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

        <section>
          <h2>How?</h2>
          <p>Overall arch</p>
        </section>

        <section>
          <h2>How?</h2>
          <p>Overall arch</p>
        </section>

        <section>
          <h2>How?</h2>
          <p>Orchestration</p>
        </section>

        <section>
          <h2>How?</h2>
          <p>Orchestration</p>
        </section>

        <section>
          <h2>How?</h2>
          <p>Natives</p>
        </section>

        <section>
          <h2>How?</h2>
          <p>Mobile</p>
        </section>

        <section>
          <h2>FP: impossible in 5 minutes, miracles in 2 days</h2>
          <aside class="notes">
            <p>What does FP promise?</p>
          </aside>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - code snippets</p>
          <p>Basic FP</p>
          <pre><code data-trim class="scala">
xs.map(f)
xs.foldLeft(0)(_ + _)
          </code></pre>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - code snippets</p>
          <p>Advanced FP: types</p>
          <pre><code data-trim class="scala">
type ReportT[B] = EitherT[Id, Throwable, B]
for {
  is ← load(input)
  r  ← foo(is)
} yield r
          </code></pre>
        </section>

        <section>
          <h2>FP doesn't solve all</h2>
          <aside class="notes">
            <p>Functional programming and strong types on their own have nothing to say or add to concucrrent systems. We accept
            that FP generally favours immutability, which aids thinking about the state of the sytem. But take the code from above:
            it recieves some input over the network, it does some processing, and sends the result potentially over some other
            network conneciton into the bowels of the system. </p>
            <p>So, we have nice pure functional code that needs to run in a complete impure world.</p>
            <p>The biggest impediment to scalable systems is contended access to shared mutable state. FP alone cannot fix that,
            we need some other approach that can help us. And in our case, this is Akka—the toolkit and runtime for actor concurrency.</p>
          </aside>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - actor based concurrency</p>
          <p>API (chunk processing)</p>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - actor based concurrency</p>
          <p>FSM</p>
        </section>

        <section>
          <h2>FP and actors don't do mathematics and machine learning</h2>
          <aside class="notes">
            <p>It's all lost. FP is great in isolation, actors are OK, but when it comes to soving truly difficult stuff,
            it's back to mutable and imperative code, preferably in C++</p>
          </aside>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Natives</p>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Natives 2</p>
        </section>

        <section>
          <h2>Event-driven, elastic, resilient and responsive</h2>
          <aside class="notes">
            <p>Reactive</p>
            <p>That's why we use immutable messages, which we transform using "basic" FP—think <code>map</code>, <code>fold</code>,
            <code>flatMap</code> (that shit!). Being event-driven (using again immutable messages) helps us in achieving the remaining
            traits of reactive systems. It means that we find it easy to scale: all it takes is to add processing nodes, which communicate
            with each other using the messages. We achieve resilience by carefully structuring the components that form the application
            into hierarchies, where parents supervise their children. In other words, we handle errors at the right place, and by handle
            we naturally don't mean <code>try { ... } catch { case t: Throwable ...}</code>. Error handling is not about being able
            to recover from any exception, but to safely get to the state the system was in before the exception. This might involve
            restarting the failing actor, hierarchy of actors, or the JVM that hosts the actors. It's the same story for the native
            components. We do not attempt to recover from any old anything, when the component gets to a state that it cannot recover
            from, it <code>exit(-1)</code>s. Finally, we achieve responsiveness by using strictly non-blocking calls throughout
            the system.</p>
          </aside>
        </section>

        <section>
          <h2>No getting away from good engineering</h2>
          <aside class="notes">
            <p>Testing. Devops.</p>
          </aside>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-stat../reveal.js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on ../reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>