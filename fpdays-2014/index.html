<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Functional programming in Finance and Healthcare</title>
    <meta name="description" content="FP Days 2014">
    <meta name="author" content="Jan Machacek, Andrew Sim">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>FP &amp; biometrics</h1>
          <p>In finance and healthcare</p>
          <p>
            <small>
              Andrew Sim <a href="https://twitter.com/andrewcsim">@andrewcsim</a><br/>
              Jan Machacek <a href="https://twitter.com/honzam399">@honzam399</a>
            </small>
          </p>
          <p>
            <small>
              <a href="http://www.cakesolutions.net/">Cake Solutions</a>
            </small>
          </p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

        <section>
          <img src="images/overall.png"/>
        </section>

        <section>
          <img src="images/server.png"/>
        </section>

        <section>
          <img src="images/cluster1.png"/>
        </section>

        <section>
          <img src="images/cluster2.png"/>
        </section>

        <section>
          <img src="images/natives.png"/>
        </section>

        <section>
          <img src="images/ios.png"/>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <img src="images/code.png"/>
          <p>All adding up to about 80,000 LoC</p>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <ul>
            <li>Scala</li>
            <li>JavaScript</li>
            <li>C++14</li>
            <li>Objective-C++</li>
            <li>Ruby</li>
          </ul>
        </section>

        <section>
          <h2>Show me the code!</h2>
          <ul>
            <li>Scala ⇒ Akka, Spray, Scalaz</li>
            <li>JavaScript ⇒ AngularJS, jQuery</li>
            <li>C++14 ⇒ CUDA, OpenCV</li>
            <li>Objective-C++ ⇒ CoreImage, GPUImage</li>
            <li>Ruby ⇒ Ruby on Rails, Puppet</li>
          </ul>
        </section>

        <section>
          <h2>Tooling</h2>
          <ul>
            <li>SBT, cmake</li>
            <li>Jenkins</li>
            <li>Gatling</li>
            <li>Puppet</li>
          </ul>
        </section>

        <section>
          <h2>FP</h2>
          <h3>Impossible in 5 minutes, miracles in 8 hours</h3>
          <aside class="notes">
            <p>It's easy to start thinking that FP is the solution to all software development problems. As in, "take complicated system,
            sprinkle with FP and all is done." I accept that this is not always the case, but FP went a long way towards helping us 
            focus on the truly complex areas without having to worry about the mundane tasks.</p>
            <p>By mundane tasks I mean mechanical transformations of data—and I're sure you're now thinking <code>map</code>, <code>filter</code>,
            <code>flatMap</code>. This, together with immutable data structures was helped us in our reasoning about the system. Where possible,
            we stayed pure, avoiding side-effects in our functions.</p>
            <p>So, let's now see how we used FP in the bowels of the system.</p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
GPUImageHoughTransformLineDetector *houghTransform = 
  [[GPUImageHoughTransformLineDetector alloc] init];
GPUImagePicture *gpuImage = 
  [[GPUImagePicture alloc] initWithCGImage:image];
[gpuImage addTarget:houghTransform];

[houghTransform setLinesDetectedBlock:
  ^(GLfloat* lineArray, NSUInteger linesDetected, 
    CMTime frameTime) {
    ...
  }];
  
[gpuImage processImage];
          </code></pre>
          <aside class="notes">
            <p>I will not bore you with the callback hell of JavaScript. Instead, I'll show you the pleasure of 
            Objective-C. (I would wholehartedly vote for Swift if I were starting the project today. Alas, Obj-C it is!)
            Here is an example of the image processing, applying the hough transform to the frames we receive from the camera.
            The FP snippet is, of course, the block <code>^(GLfloat* lineArray, NSUInteger linesDetected, CMTime frameTime)</code>.
            What you may also spot is that the GPUImage processing is asynchronous: that is, we supply the function (block in 
            Objective-C parlance), which contains the logic we want to perform, and only later on trigger the computation using
            <code>[gpuImage processImage]</code>.</p>
            <p>So, in addition to the comfortable concepts of FP, we need to be able to handle asynchronous and non-blocking code,
            together with the necessary synchronisation code between threads. This is just about doable in a small app running
            on the mobile, but it would be completely impossible to achieve on the server. But more on that later.</p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
typedef enum PVTestResult {
    Stop = 0,
    ContinueSucceed,
    ContinueFail
} PVTestResult;

typedef PVTestResult (^AllImagesTest)
  (CMSampleBufferRef, CMTime, uint);

@interface PVTestCase : XCTestCase 
- (uint)allImagesIn:(PVTestSource *)source 
  inRealTime:(bool)rt must:(AllImagesTest)test;
@end
          </code></pre>
          <aside class="notes">
            <p>As good engineers, we of course thoroughly test our code. And we can bring back the FP concepts: here, 
            for example having a test that checks that all video frames in the given <code>source</code> (possibly played
            back in real time—that is frames that are not processed in time are skipped—must satisfy some <code>test</code></p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
- (void)testDocumentCapture {
  for (PVTestSource *source in ...) {
    [self allImagesIn:source inRealTime:true 
          must:^PVTestResult(CGImageRef frame, ...) {
      PVDocumentPreflightResult result = 
        [checker preflight:frame];
      if (result.pass) {
          PVAssertSameImage(frame, [source image]);
          return Stop;
      }
      return ContinueFail;
    }];
  }
}
          </code></pre>
          <aside class="notes">
            <p>Usage of our testing framework is quite trivial—though the most difficult task was to collect all the input data.
            We ended up with thousands of videos and images, collected during our testing phase. As you can expect—the test
            data set is constantly growing. And with it, test times, but that's a topic for a separate talk! We must press on.</p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <video controls>
            <source src="videos/document.mp4" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        </section>

        <section>
          <h2>Mobile</h2>
          <video controls>
            <source src="videos/face.mp4" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        </section>

        <section>
          <h2>Orchestration</h2>
          <p>Orchestration - code snippets</p>
          <p>Basic FP</p>
          <pre><code data-trim class="scala">
xs.map(f)
xs.foldLeft(0)(_ + _)
          </code></pre>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - code snippets</p>
          <p>Advanced FP: types</p>
          <pre><code data-trim class="scala">
type ReportT[B] = EitherT[Id, Throwable, B]
for {
  is ← load(input)
  r  ← foo(is)
} yield r
          </code></pre>
        </section>

        <section>
          <h2>FP alone doesn't solve all</h2>
          <aside class="notes">
            <p>Functional programming and strong types on their own have little to say or add to mutating concucrrent systems. We accept
            that FP generally favours immutability, which aids thinking about the state of the sytem. But consider our system:
            it recieves some input over the network, it does some processing, and sends the result potentially over some other
            network conneciton.</p>
            <p>So, our nice pure functional code that needs to run in a completely impure world. To make matters even worse,
            this impure world is concurrent, with many users making changes to the domain. Recall that our domain is 
            all users with all their faces, and all their transactions.</p>
            <p>I will shamelessly quote-mine Jonas Boner, who said that the biggest impediment to scalable systems is contended access 
            to shared mutable state. FP alone cannot fix that, we need some other approach that can help us. And in our case, this is 
            Akka—the toolkit and runtime for actor concurrency.</p>
          </aside>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
trait ImageStreamingService with Directives {
  this: Actor ⇒
  import context.dispatcher
  def streamingRoute(proc: ActorRef): Route = 
    path("process" / JavaUUID / "face") { id: UUID ⇒
      post {
        sender() ! RegisterChunkHandler(
          context.actorOf(Props(classOf[Handler], 
                          proc, id))))

        const(())
      }
    }
}
          </code></pre>
        </section>

        <section>
          <h2>Actor concurrency &amp; FP</h2>
          <pre><code data-trim class="scala">
class Handler(proc: ActorRef, id: UUID) extends Actor {
  var buffer = ByteString()
  def receive = {
    case MessageChunk(data, _) ⇒
      buffer = buffer ++ data
      if (isComplete(buffer)) {
        buffer = ByteString.empty
        proc ! ProcessFaceFrame(id, buffer)
      }
    case ChunkedMessageEnd(_, _) ⇒
      proc ! EndFaceStep(id)
      context.stop(self)
  }
}
          </code></pre>
        </section>

        <section>
          <h2>What? (Andrew)</h2>
          <p>Orchestration - actor based concurrency</p>
          <p>FSM</p>
        </section>

        <section>
          <h2>FP and actors don't do mathematics and machine learning</h2>
          <aside class="notes">
            <p>It's all lost. FP is great in isolation, actors are OK, but when it comes to soving truly difficult stuff,
            it's back to mutable and imperative code, preferably in C++</p>
          </aside>
        </section>

        <section>
          <h2>Mobile</h2>
          <pre><code data-trim class="objectivec">
float* buf = ...;
DSPSplitComplex res = { buf, buf + N/2 };
FFTSetup fftSetup = 
  vDSP_create_fftsetup(17, FFT_RADIX2);
vDSP_fft2d_zrip(fftSetup, 
  &amp;res, 1, 0, 
  Log2C, Log2R, 
  kFFTDirection_Forward);
          </code></pre>
          <aside class="notes">
            <p>Unfortunately, not all code is nicely functional: sometimes, it is necessary to leave the comforts of FP behind,
            and drop down to the unpleasantness of unmanaged pointers, strange memory layouts, and whatever else the hardware
            needs. In this particular case, we're using the iPhone's DSP to process portions of the image, and this approach
            gave us more than 5 x improvement in processing speed, and much lower power consumption.</p>
          </aside>
        </section>

        <section>
          <h2>Server-side image processing</h2>
          <pre><code data-trim class="cpp">
class FaceVerify {
public:
  FaceVerify(CoreShared &amp;c, PreCalcWavShared &amp;w);
  Encoding encodeImage(Image &amp;image, std::string ...);
private:
  bool calcJets(PixGrid &amp;PG);
};

class CoreShared {
public:
  CoreShared();
private:
  class WaveletGrid { ... };
  WaveletGrid m_WG[MAX_WAVELET_GRIDS];

  cvm::rmatrix **m_pmDataT;
  cvm::rmatrix **m_pmCoeffVectsSigT;
};
          </code></pre>
          <aside class="notes">
            <p>What can I add? We—and this is royal we now—had to abandon all hope of comfortable programming, garbage collectors and
            other such creature comforts, and get our hands dirty. Nevertheless, our aim was to build the system as a collection of
            independent and well-defined components with clear communication mechanism between them. And so, all of this rather complex
            code—with all its tests and training programs that we're not even showing here—are wrapped in code that ultimately receives a
            message and replies back to the sender. This follows the same pattern as the Actor-based code in Scala, which makes it
            easier to reason about the system.</p>
          </aside>
        </section>

        <section>
          <h2>Server-side image processing</h2>
          <pre><code data-trim class="cpp">
class Main : public RabbitRpcServer {
  public:
    Main(const std::string queue, ...);
    virtual ~Main();
  protected:
    virtual std::string handleMessage(
      const AmqpClient::BasicMessage::ptr_t message, 
      const AmqpClient::Channel::ptr_t channel);
}
          </code></pre>
          <aside class="notes">
            <p>Every native component (faceverify, faceextract, document, ...) needs to handle messages arriving to it from
            RabbitMQ. </p>
          </aside>
        </section>

        <section>
          <h2>Event-driven, elastic, resilient and responsive</h2>
          <aside class="notes">
            <p>Reactive</p>
            <p>That's why we use immutable messages, which we transform using "basic" FP—think <code>map</code>, <code>fold</code>,
            <code>flatMap</code> (that shit!). Being event-driven (using again immutable messages) helps us in achieving the remaining
            traits of reactive systems. It means that we find it easy to scale: all it takes is to add processing nodes, which communicate
            with each other using the messages. We achieve resilience by carefully structuring the components that form the application
            into hierarchies, where parents supervise their children. In other words, we handle errors at the right place, and by handle
            we naturally don't mean <code>try { ... } catch { case t: Throwable ...}</code>. Error handling is not about being able
            to recover from any exception, but to safely get to the state the system was in before the exception. This might involve
            restarting the failing actor, hierarchy of actors, or the JVM that hosts the actors. It's the same story for the native
            components. We do not attempt to recover from any old anything, when the component gets to a state that it cannot recover
            from, it <code>exit(-1)</code>s. Finally, we achieve responsiveness by using strictly non-blocking calls throughout
            the system.</p>
          </aside>
        </section>

        <section>
          <h2>No getting away from good engineering</h2>
          <aside class="notes">
            <p>Testing. Devops.</p>
          </aside>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video VeriSure</p>
        </section>

        <section>
          <h2>Demo</h2>
          <p>Video InstaSure</p>
        </section>

        <section>
          <h2>More applications</h2>
          <p></p>
        </section>

        <section>
          <h2>Thank you!</h2>
          <ul>
            <li>Other interesting work at <a href="http://www.cakesolutions.net">www.cakesolutions.net</a></li>
            <li>Slides at <a href="http://www.eigengo.com/fpdays-2014">www.eigengo.com/fpdays-2014</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a> | <a href="https://twitter.com/andrewcsim">@honzam399</a></li>
          </ul>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-stat../reveal.js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on ../reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>