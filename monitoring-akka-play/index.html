<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Monitoring Akka &amp; Play</title>
    <meta name="description" content="Monitoring Akka &amp; Play">
    <meta name="author" content="Jan Machacek, Alex Lashford">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-background="images/intro.png">
          <h1>Monitoring Akka&nbsp;&amp;&nbsp;Play</h1>
          <h3>The how and the what</h3>
          <p>
            <small>
              Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a>&nbsp;&nbsp;|&nbsp;&nbsp;
              Alex Lashford <a href="https://twitter.com/alexlashford">@alexlashford</a>
            </small>
          </p>
          <p>
            <small><a href="http://www.eigengo.com/monitoring-akka-play">www.eigengo.com/monitoring-akka-play</a></small>
          </p>
        </section>

        <!-- Monitoring -->
        <section data-background="images/everythingfine.jpg">
          <h2>So, tell me again</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>how everything's fine in production!</h2>
          <aside class="notes">
              Monitoring gives an insight into the performance and flow of an application,
              allowing us see pain points, and areas of poor performance: increasing our visibility to what is occuring.
              The aim is 24/7 uptime, preventing the big boom! How do you know that something's broken in time to do something about it? It is insufficient to monitor HTTP 500s, we want to have a bit of time ahead of the 500s to do something.
          </aside>
        </section>

        <!-- Production ready?-->
        <section data-background="images/fineindev.jpg">
          <h2>Worked fine in dev—ops problem now!</h2>
          <p>We create actor systems in Akka (perhaps with REST APIs in Spray); modern web applications in Play, and we all like to think that these applications will attract <strike>thousands</strike> billions of users.</p>
          <aside class="notes">
              <p>So are you ready for production?</p>
              <p>Here at Scala Days we have seen some great talks, so I bet you're itching to get back and do some coding. But what happens when you have created the next Netflix? Unfortunatly, Akka does not solve all of the woes of running in production, you still need to keep an eye on your stack.</p>
              <p>What is happening <em>inside</em> the application?</p>
              <ul>
                <li>Do we have any hotspots in our actor system?</li>
                <li>Are the message queues getting too big? (Are the messages spending too much time in the queues?)</li>
                <li>Do we have enough threads, and are the threads being blocked?</li>
              </ul>
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>What to Monitor</h2>
          <p>You want to see inside the Akka, Play Framework or Spray and know what is happening in the system's components.</p>
          <br/>
          <ul>
            <li>Number / rates of messages</li>
            <li>Sizes of queues</li>
            <li>Duration of messages in queue</li>
            <li>Time it takes to execute the <code>receive</code> PF</li>
            <li>Number / rates of failures</li>
            <li>The threads in the thread pools</li>
          </ul>
           <aside class="notes">
             What metrics do you want to see, when the app is in production. 

             During our consultancy, customers often complain that actors are black boxes. It is difficult to understand what the application is doing; especially if they come from a traditional JEE background.
          </aside>
        </section>

        <!-- how we did it -->
        <section data-background="images/monitor.jpg">
          <h2>Typesafe Console!</h2>
          <img src="images/console.png"/>
          <aside class="notes">
            Typesafe Console! It looks great, and it gives in-depth stats on the actor system.
          </aside>
        </section>

        <!-- how we did it -->
        <section data-background="images/monitor.jpg">
          <h2>Typesafe Console!</h2>
          <p>Brilliant, looks great, under low load its really impressive. We loved it, but ...</p>
          <ul>
            <li>Production—unusable: volume of data produced, memory footprint, I/O</li>
            <li>Development—great: gives in–depth view of the actor system</li>
          </ul>
          <aside class="notes">
            But it records too much data and just eats resource when doing performance tests. 
            In summary:
            * production is a no go
            * development is recomended, great for tracing the flow through the actor system. 
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Reactive Monitor</h2>
          <p>We wanted to record <em>just enough</em> information. Too much slows down the monitored system, too little lets events go unnoticed.</p>
          <p>And we wanted to have a flexible mechanism to deliver the collected monitoring information.</p>
          <ul>
            <li>Actor creation &amp; destruction.</li>
            <li>Message types, message rates, failures and performance at the actor level</li>
            <li>Queue size at the (local) actor level</li>
            <li>The number of available and running threads in the <code>ThreadPool</code>s</li>
          </ul>
          <aside class="notes">
            We liked the Typesafe Console, but we needed an alternative solution for the client. So, we scratched our own itch, and made the open source Reactive Monitor. Instead of targetting <em>only</em> statsd (with Datadog), we split the agents and the outputs.
            At the highest level, the architecture is:
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Reactive Monitor</h2>
          <img src="images/architecture.png"/>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
val system = ActorSystem()
val x = system.actorOf(Props[XActor])
val y = system.actorOf(Props[YActor])
x ! "foo"
y ! "foo"
y ! 42
          </code></pre>
          <aside class="notes">
            With this code, what sort of metrics can you get with our monitoring tool?
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
x ! "foo"; y ! "foo"; y ! 42
          </code></pre>
          <img src="images/chart.png"/>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
val system = ActorSystem()
val x = system.actorOf(Props[XActor])
val y = system.actorOf(Props[YActor])
x ! "foo"
y ! "foo"
y ! 42
          </code></pre>
          <aside class="notes">
            Remember, we do not want to have to modify our source code, nor do we want to maintain a custom
            fork of Akka, Play, Spray, ...!

            You source code stays the same...
          </aside>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <p>It allows us to instrument Akka's and Play's bytecode as it is loaded by the <code>ClassLoader</code>s. We can do 
            <em>anything</em> we like, as long as the instrumented bytecode verifies. </p>
          <img src="images/ltw.png"/> 
          <aside class="notes">
            This is how we apply the agents into the application being monitored. We used AspectJ LTW to monkey-patch Akka's, Spray's and Play's JARs. This means that there are no custom builds of Akka, Spray or Play!
          </aside>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <p>To <em>turn on</em> LTW, set the <code>-javaagent</code> JVM parameter, and add <code>/META-INF/aop.xml</code>.</p>
          <pre><code data-trim class="xml">
&lt;aspectj&gt;
    &lt;aspects&gt;
        &lt;aspect name="ActorCellMonitoringAspect"/&gt;
        &lt;aspect name="DispatcherMonitoringAspect"/&gt;
    &lt;/aspects&gt;
    &lt;weaver options="-verbose -showWeaveInfo"&gt;
        &lt;include within="akka.actor.*"/&gt;
        &lt;include within="akka.dispatch.*"/&gt;
        &lt;include within="scala.concurrent.*"/&gt;
        &lt;include within="java.util.concurrent.*"/&gt;
    &lt;/weaver&gt;
&lt;/aspectj&gt;
          </code></pre>
          <aside class="notes">
            aop.xml tells the weaver where to unleash its monkey-patching magic. In other words, we restrict the scope of the work that the weaver has to do.
          </aside>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <pre><code data-trim class="java">
public aspect ActorCellMonitoringAspect {

  Object around(ActorCell actorCell, Object msg) : 
    call(* a.a.ActorCell.receiveMessage(..)) 
    &amp;&amp; args(msg) &amp;&amp; target(actorCell) {
      // check configuration to see if we're interested
      // publish 'delivered' events
      // measuring performance
      Object result = proceed(actorCell, msg);
      // return null would do, but we are _proper_.
      return result;
  }
}
          </code></pre>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <pre><code data-trim class="java">
public aspect DispatcherMonitoringAspect {

  before(ExecutorService es) : 
    call(* j.u.c.ExecutorService+.execute(..)) 
    &amp;&amp; target(es) {
      // publish 'active threads' count
      // publish 'running threads' count
    }

}
          </code></pre>
        </section>

        <section data-background="images/agent.jpg">
          <h2>Agents</h2>
          <ul>
            <li><strong>Akka</strong> - measuring actor instances, their performance, failures, messages, message queues and threads</li>
            <br/>
            <li><strong>Spray</strong> - measuring the HTTP requests, and bytes transferred</li>
            <br/>
            <li><strong>Play</strong> - measuring the HTTP requests, controller performance and failures</li>
          </ul>
          <aside class="notes">
            <p>Nota bene that Spray is based on Akka, so the I/O traffic is <em>in addition</em> to everything that the Akka agent measures</p>
            <p>The agents are essentially a collection of aspects that instrument the interesting methods in their target, and report the information they collected to the configured <em>output</em> module.</p>
          </aside>
        </section>

        <section data-background="images/agent.jpg">
          <h2>Akka Agent</h2>
          <p>We have some specific instrumenation around some of the useful intractions in the Akka framework, including support for both the Java and Scala Api's</p><br/>
          <ul>
            <li>Actor instances</li>
            <li>Avergage time in onRecieve()</li>
            <li>Mailbox size</li>
            <li>Mailbox duration</li>
            <li>Number of Exceptions</li>
            <li>Executor / Thread data</li>
          </ul>
          <aside class="notes">
            <p>instrumentation around specific akka interactions, i,e  Actor Count, Avg OnRecieve ...</p>
          </aside>
        </section>

         <section data-background="images/agent.jpg">
          <h2>Play Framework Agent</h2>
          <p>Instrumenation around some of the useful intractions in the Play Framework, including support for both the Java and Scala Api's</p><br/>
          <ul>
            <li>Number of Requests</li>
            <ul>
              <li>Grouped by Route</li>
            </ul>
            <li>Number of Exceptions</li>
          </ul>
          <aside class="notes">
            <p>instrumentation around specific Play interactions, i,e  Request Count grouped by Route / Path, Error / Exception count...</p>
          </aside>
        </section>

         <section data-background="images/agent.jpg">
          <h2>Spray Agent</h2>
          <p>Provides instrumenation for the Spray libraries</p><br/>
          <ul>
            <li>Number of Requests</li>
            <ul>
              <li>Grouped by Route</li>
            </ul>
            <li>Number of Exceptions</li>
          </ul>
          <br/><br/>
          <p>* In addition to all of the Akka Agent metrics</p>
          <aside class="notes">
            <p>Provide the hooks and instrumenation around around the spray Api, i,e  Request Count grouped by Route / Path, Error / Exception count.  in addtiion to all the metrics you get with the Akka agent...</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Output modules</h2>
          <p>The aspects load configurable output modules. We scratched our own itch by implementing the statsd / Datadog output module, but we have two more!</p>
          <ul>
            <li>statsd (with <a href="http://www.datadoghq.com/" target="_blank">Datadog</a> extensions)</li>
            <li>DTrace (on Solaris, dummy elsewhere)</li>
            <li>Codahale Metrics</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Statsd</h2>
          <p>Really simple transport: strings up to 508 bytes long over UDP.</p>
          <pre><code data-trim>
aspect ':' value '|' type '|#' tag1 ',' tag2 ',' ...
          </code></pre>
          <p>For example, in our application</p>
          <pre><code data-trim class="no-highlight">
akka.actor.delivered:50|c|#↩
  akka://default/user/x,akka.type:default.org...XActor
akka.actor.delivered.Integer:50|c|#↩
  akka://default/user/x,akka.type:default.org...XActor
akka.actor.duration:99|ms|#↩
  akka://default/user/x,akka.type:default.org...XActor
          </code></pre>
          <aside class="notes">
            <p>statsd is a light-weight UDP-based protocol to send tracing information to anything that can understand the datagrams. The datagrams carry specifically-formatted strings. Hence Datadog (and others) can offer extensions to the standard stasd formats easily.</p>
            <p>The <code>type</code> can be either 'c' for count—increments and decrements, 'g' for gauge—absolute value, and 'ms' for execution time.</p>
            <p>We can get away with this—the minimum MTU on the internet is 576, the size of the IPv4 header at most 60 bytes, and the UDP header 8 bytes. This leaves 508 bytes available for the monitoring data.</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Statsd</h2>
          <p>Most statsd tools can show very pretty charts.</p>
          <img src="images/datadog1.jpg"/>
          <aside class="notes">
            <p>There are plenty of tools that can listen for the statsd datagrams, and analyse the data. Typically, they have pretty user interfaces, charts, alerts, ...</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Statsd</h2>
          <pre><code data-trim class="scala">
class StatsdActor(remote: InetSocketAddress, 
                  prefix: String) extends Actor {
  IO(Udp) ! Udp.SimpleSender
  def receive: Receive = {
    case Udp.SimpleSenderReady =>
      context.become(ready(sender))
  }
  def ready(send: ActorRef): Receive = {
    case stat: StatsdStatistic =>
      val payload = toByteString(stat, prefix)
      send ! Udp.Send(payload, remote)
  }
}
          </code></pre>
          <aside class="notes">
            <p>In keeping with the asynchronous approach, the I/O that this output module produces is isolated in its own <code>ActorSystem</code>. This means that the output module has as little impact on your application as possible.</p>
            <p>its also note worthy that the datagrams are sent over UDP so even at a low level there is no blocking as the Ststad client is not waiting for an ack of the message.</p>
            <p>so in summary, Statsd is lightwieght, simple first impl was only 137 lines long, widly supported, DataDog, Graphite etc.</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>DTrace</h2>
          <p>DTrace is kernel-level, production-ready, minimal-impact tracing mechanism.</p>
          <pre><code data-trim class="bash">
$ sudo dtrace -l
ID   PROVIDER            MODULE     NAME
 1     dtrace                       BEGIN
 2     dtrace                       END
 3     dtrace                       ERROR
 4 nfsmapid804          nfsmapid    daemon-domain
 5 kerberos800    mech_krb5.so.1    krb_ap_rep-make
   ...
33 akka2083         java_tracing    all-gauges
34 akka2083         java_tracing    execution-time
35 akka2083         java_tracing    all-counters          
          </code></pre>
          <aside class="notes">
            <p>There are ports of DTrace from Solaris to Linux, NetBSD and others. Reactive Monitor adds probes using JVM's tracing APIs, and even though for example OS X includes dtrace, the JVM on OS X does not "talk" to dtrace.</p>
            <p>DTrace's <em>probes</em> are roughly comparable to pointcuts: that is, they point to a specific location in execution flow. When the execution hits the probe, it fires.</p>
            <p>One writes D programs that attach to the firing probes and execute C-like code. In the bodies of the probes, you can do arbitrary operations. Imagine, for example, being able to automatically modify the zone's CPUs, memory, and so on! In fact, this is what we're working on with Joyent. So go ahead and take a peek!</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>DTrace</h2>
          <p>The actual interface relies on the <em>internal</em> tracing API that the Oracle JDK and OpenJDK provides.</p>
          <pre><code data-trim class="java">
@ProviderName("akka")
public interface DtraceCounterProvider 
    extends com.sun.tracing.Provider {

    @FunctionName("Receive execution time")
    @ProbeName("execution-time")
    void executionTime(String name, int length, 
                       int duration);

    ...
}
          </code></pre>
          <aside class="notes">
            <p>The annotations and the <code>Provider</code> interface itself are internal APIs; also notice that we have to be careful when sending the <code>String</code>s, and include the string's length and be sure that the character encoding is known. This will all become really important when we take a look at the D script that follows.</p>
            <p>We then use JDK's tracing provider to get a JDK proxy that conforms to our interface, that—on Solaris—creates the DTrace entries when we call the interface's methods. Outside Solaris, we get a dummy implementation of this interface. We tried this on latest OS X, latest Ubunbu, latest CentOS, and Solaris 11; all with Oracle's JDK, and OpenJDK on OS X.</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>DTrace</h2>
          <p>The D program needs to copy in data from kernel space to the user space where the program runs.</p>
          <pre><code data-trim class="D">
akka$1:::exeucution-time {
  printf("execution time: %s -> %d", 
    stringof(copyin(arg0, arg1 + 1)), arg2);
}

akka$1:::all-counters {
  printf("counter: %s -> %d", 
    stringof(copyin(arg0, arg1 + 1)), arg2);
}
          </code></pre>
          <pre><code data-trim class="bash">
$ sudo dtrace -s script.d `pgrep java`
          </code></pre>
          <aside class="notes">
            <p>Notice in particular the <code>copyin</code> and <code>stringof</code> calls. The first one deals with copying kernel memory from the pointer <code>arg0</code>, taking <code>arg1</code> bytes. This is exactly the place where one needs to be aware of string encoding (anyone fancies using unicode names for actor names?)</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Codahale Metrics</h2>
          <p>A metrics library in Java (and Scala) that allows us to deliver measurement types similar to 
          what statsd can do.</p>
          <p>Unlike statsd, Metrics is the entire monitoing framework. It processes the information it receives, performs
          the calculations we want, and exposes the measurements.</p>
          <aside class="notes">
            <p>It can expose the data using Ganglia (!!), statsd (!!), console, CSV, JMX, HTTP; all that you have to do is to bring in the specific dependencies, in addition to the <code>output-codahalemetris</code> module from Reactive Monitor</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Codahale Metrics</h2>
          <pre><code data-trim class="scala">
class MetricsCounterInterface 
  extends CounterInterface with MetricsHandler {

  def registry: MetricRegistry = ...
  def marshaller: NameMarshaller = ...

  def recordExecutionTime(aspect: String, 
                          duration: Int, 
                          tags: String*): Unit =
    updateExecutionTime(aspect, duration, tags)
  
  ...
}
          </code></pre>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <p>The aspects need configuration for the <em>agent</em>s and <em>output</em>s.</p>
          <ul>
            <li>Decide which actors to monitor</li>
            <li>How to aggregate the monitoring data</li>
            <li>How to deliver the monitoring data</li>
          </ul>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <p>Typesafe Config-style files at well-known locations configure the agent and output modules.</p>
          <ul>
            <li><code>/META-INF/monitor/agent.conf</code> for the agent</li>
            <li><code>/META-INF/monitor/output.conf</code> for the output</li>
          </ul>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.agent {
  output.class: "org...StatsdCounterInterface"

  akka {
    included: [
      "akka:default.org...SimpleActor",
      "akka://default/user/x"
    ]
    sampling: [
      { rate: 5, for: [ "akka://default/user/*" ] }
    ]
  }
}          
          </code></pre>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.output.statsd {
    prefix: ""
    remoteAddress: "localhost"
    remotePort: 8125
    refresh: 5
    initialDelay: 5
    constantTags: []
}
          </code></pre>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.output.codahalemetrics {
    registry-class: "org...DefaultRegistryProvider"
    naming-class:   "org...DefaultNameMarshaller"
    prefix: ""
    refresh: 5
}
          </code></pre>
        </section>

        <section data-background="images/angrymob.jpg">
          <h2>Into the battle!</h2>
          <ul>
            <li>Dependencies for the agents and output modules you require
              <pre><code data-trim class="scala">
"org.eigengo.monitor" % "agent-akka"    % "0.4",
"org.eigengo.monitor" % "output-statsd" % "0.4"
              </code></pre>
            </li>
            <li>Agent configuration in <code>/META-INF/monitor/agent.conf</code><br/>
              and—if required—<br/>
              Output configuration in <code>/META-INF/monitor/output.conf</code></li>
            <li><code>/META-INF/aop.xml</code> to give configuration to the weaver</li>
          </ul>
        </section>

        <!-- demo -->
        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Let's add monitoring to statsd &amp; Datadog to an Akka application</p>
          <img src="images/activatorapp.png"/>
        </section>
        
        <section data-background="images/production.jpg">
          <h2>War stories?</h2>
          <br/><br/>
          <p>What have we learnt in building the Reactive Monitor?</p>
          <p>&nbsp;</p>
          <p>What have we learnt in building a large Akka system?</p>
          <aside class="notes">
              Well, yes it is possible to Monitor too much, you need to be pragmatic over the metrics you want to record and you should always `sample`.  Nothing comes for free, the more you monitor the more data is sent over the wire the more computation that is performed.  

              But it is a nessarary evil, the visibility and the insight into the app montoring provides is invaluable in production.  

              So one of our clients hired us to write a large Akka system that could serve millions of requests a day, early on in the project we had enough functionlaity to start running some performance tests.

              Im sure this has happended to all of us at some point in the past, your first performance tests just sit there, not really taking hardware resource, essentially just "blocking". 
             
              We saw via the monitor mailbox queues growing, mean-time in 'onRecieve()' being too high. arrrrhhhhh...
          </aside>
        </section>

        <section data-background="images/production.jpg">
          <h2>Analysed the architecture</h2>
          <p>CPU-intensive (XML parsing)</p>
          <p>Non-reactive / blocking third-party libraries (DB drivers, ....)</p>
          <p>Reactive libraries (Async HTTP)</p>
          <aside class="notes">
              So we looked at the architecture, as in most big systems, we had a mixed bad of tech:
              CPU-intensive  - Churning through lots of Data, big XML files, Big Data problems
              Non-reactive - Legacy code, Blocking Libraries database integration etc...
              lots of Awesome Reactive stuff, Async Http, async db drivers all none blocking.
              and of cause then Actor system its self.  This all looked good, we had split the functional areas up into Actors or Sets of Actors all seemed nicely cohesive.  
              Then light bulb momment...
          </aside>
        </section>

        
        <!-- what did we do? -->
        <section data-background="images/production.jpg">
          <h2>Bulkhead the operations</h2>
          <p>Isolated the actor system into functional areas:</p>
          <ul>
            <li>Legacy blocking code - PinnedDispatcher</li>
            <li>CPU intensive code - BalancingDispatcher</li>
            <li>Remaining reactive code - fork-join-executor / executor</li>
          </ul>
          <br/>
          <br/>
          <p>Creating different dispatchers for the unruly code</p>
          <a href="http://letitcrash.com/post/40755146949/tuning-dispatchers-in-akka-applications">Letitcrash.com -> tuning-dispatchers-in-akka-applications</a>
          <aside class="notes">
              
              Bulkheading - So, we needed to bulkhead the app, we had it logically seperated in the architecture, but we still had the example app dispatcher config. 
              legacy Code - blocking code that we wanted to issolate -
              CPU intensive - didn't want this code to starve the actor system
              Everything else can have a shared pool 
              Deciding on the best dispatcher for a given actor is tricky and a lot of reading needs to be done, there are some bad blogs outthere but the blog from the typesafe guys is a good place to start.
          </aside>
        </section>

        <section data-background="images/theend.jpg">
          <h2>Nearly over!</h2>
          <h4>Remember...</h4>
          <ul>
            <li>Visibility is King</li>
            <li>Monitor only what you need</li>
            <li>Don't wait for the Big Boom!</li>
            <li>Bulkhead your application</li>
          </ul>
          <br/><br/>
          <h4>Happy coding...</h4>
          <aside class="notes">
             Bulkhead - Remember Akka 101 apps dont provide `Production` ready config
          </aside>
        </section>

        <section data-background="images/devops.jpg">
          <h2>Thank you!</h2>
          <ul>
            <li>Source at <a href="https://github.com/eigengo/monitor">github.com/eigengo/monitor</a></li>
            <li>Slides at <a href="http://www.eigengo.com/monitoring-akka-play">www.eigengo.com/monitoring-akka-play</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a> | <a href="https://twitter.com/alexlashford">@alexlashford</a></li>
          </ul>
          <hr/>
          <p><big>Law of Murphy for devops: if thing can able go wrong, is mean is already wrong but you not have Nagios alert of it yet.</big></p>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
