<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Monitoring Akka &amp; Play</title>
    <meta name="description" content="Monitoring Akka &amp; Play">
    <meta name="author" content="Jan Machacek, Alex Lashford">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-background="images/intro.png">
          <h1>Monitoring Akka&nbsp;&amp;&nbsp;Play</h1>
          <h3>The how and the what</h3>
          <p>
            <small>
              Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a>&nbsp;&nbsp;|&nbsp;&nbsp;
              Alex Lashford <a href="https://twitter.com/alexlashford">@alexlashford</a>
            </small>
          </p>
          <p>
            <small><a href="http://www.eigengo.com/monitoring-akka-play">www.eigengo.com/monitoring-akka-play</a></small>
          </p>
        </section>

        <!-- what's happening -->
        <section>
          <h2>Why</h2>
          <p>Why monitor? What do you get, what happens when you don't ...</p>
          <ul>
            <li>Improved visibility</li>
            <li>Identify "Pain Points"</li>
            <li>Provide information to prevent the "big boom!"</li>
          </ul>
          <aside class="notes">
              Monitoring gives us an insight into the performance and flow of an application
              Allowing us see "pain points", areas of poor performance
              Generally increasing our visibility to what is occuring
              The Aim is 24/7 uptime, preventing the big boom! 
              How do you know that something's broken in time to do something about it.
              We don't want to "monitor" HTTP 500s, we want to have a bit of time ahead
              of the 500s to do something.
          </aside>
        </section>

        <section>
          <h2>Kinds of things in big system</h2>
          <p>CPU-intensive (XML parsing)</p>
          <p>Non-reactive / blocking third-party libraries (DB drivers, ....)</p>
          <p>The reactive rest (async HTTP libs, DB drivers, ...: most of them Netty, not Akka IO)</p>
          <p>The ActorSystem</p>
          <aside class="notes">
              CPU-intensive  - Churning through lots of Data, big XML files, Big Data problems
              Non-reactive - Legacy code, Blocking Libraries database integration etc...
              lots of Awesome Reactive stuff, Async Http, async db drivers all none blocking.
              and ofcause then Actor system its self.  
          </aside>
        </section>

        <section>
          <h2>The bad stuff</h2>
          <p>Not making most of the hardware: low CPU, low memory, lots of context switches and idle threads</p>
          <p>Actor queues growing too much</p>
          <p>Ultimately, the system was slow: not responsive enough</p>
          <aside class="notes">
              Im sure this has happended to all of us at some point in the past, your first performance tests just sit there, not really taking hardware resource, essentially just "blocking". 
              With more Akka specific problems, you can have mailbox queues growing, mean-time in 'onRecieve()' being too high. arrrrhhhhh...
          </aside>
        </section>

        <!-- what did we do? -->
        <section>
          <h2>Bulkhead the operations</h2>
          <p>Issolated the actor system into:</p>
          <ul>
            <li>CPU intensive </li> 
            <li>legacy blocking code </li>
            <li>remaining reactive code</li>
          </ul>
          <p>Creating different Dispatchers for the unruly code</p>
          <a href="http://letitcrash.com/post/40755146949/tuning-dispatchers-in-akka-applications">tuning-dispatchers-in-akka-applications</a>
          <aside class="notes">
              so What did we do?
              Bulkheading - So, we needed to bulkhead the app, break out the CPU intensive work, the fast reactive core and the integration to the legacy blocking code.  Deciding on the best dispatcher for a given actor was tricky but the blog from the typesafe guys was a good place to start.
          </aside>
        </section>

        <section>  
          <h2>Monitor</h2>
          <p>what metrics did we want?</p>
          <ul>
            <li>The number of messages</li>
            <li>The sizes of queues</li>
            <li>The duration of messages in queue</li>
            <li>The duration of message in the <code>Actor.receive</code></li>
            <li>Exceptions</li>
          </ul>
           <aside class="notes">
             We then thought about the metrics we would want to know, when the app was in production. 
          </aside>
        </section>

        <section>
          <h2>Correlate with</h2>
          <p>Kill?</p>
          <p>What the front-end is doing by Monitoring</p>
           
          <ul>
            <li>The number of HTTP requests</li>
            <li>Timing the HTTP responses</li>
            <li>Exceptions</li>
          </ul>
          <aside class="notes">
             and we would want to correlate this with what was going on in the front end. 
          </aside>
        </section>

        <!-- how we did it -->
        <section>
          <h2>Typesafe Console!</h2>
          <p>Brilliant, clients loved it, but ...</p>
          <p>Development OK, in fact recommended</p>
          <p>Unusable in production: memory footprint, data (MongoDB) size, the volume of data produced</p>
          <img src="images/activator.png"/>
          <aside class="notes">
            Typesafe Console! looks great, gave indepth stats on the actor system.
            just logged too much data and just ate resource when doing performance tests. 
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Reactive Monitor</h2>
          <p>We wanted to record <em>just enough</em> information. Too much would slow the system under monitor down, too little would allow failures to go unnoticed.</p>
          <ul>
            <li>Actor creation &amp; destruction.</li>
            <li>Message types, message rates, failures and performance at the actor level</li>
            <li>Queue size at the local actor level</li>
            <li>The number of active and running threads in the <code>ThreadPool</code>s or <code>ExecutorService</code>s</li>
          </ul>
          <p>And we wanted to have a flexible mechanism to deliver the monitoring output.</p>
           <aside class="notes">
            So we rolled our own OpenSource monitor... 
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Reactive Monitor</h2>
          <img src="images/architecture.png"/>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
val system = ActorSystem()
val x = system.actorOf(Props[XActor])
val y = system.actorOf(Props[YActor])
x ! "foo"
y ! "foo"
y ! 42
          </code></pre>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
x ! "foo"; y ! "foo"; y ! 42
          </code></pre>
          <img src="images/chart.png"/>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <p>It allows us to instrument Akka's and Play's bytecode as it is loaded by the <code>ClassLoader</code>s. We can do 
            <em>anything</em> we like, as long as the instrumented bytecode verifies. </p>
          <img src="images/ltw.png"/> 
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <p>To <em>turn on</em> LTW, set the <code>-javaagent</code> JVM parameter, and add <code>/META-INF/aop.xml</code>.</p>
          <pre><code data-trim class="xml">
&lt;aspectj&gt;
    &lt;aspects&gt;
        &lt;aspect name="ActorCellMonitoringAspect"/&gt;
        &lt;aspect name="DispatcherMonitoringAspect"/&gt;
    &lt;/aspects&gt;
    &lt;weaver options="-verbose -showWeaveInfo"&gt;
        &lt;include within="akka.actor.*"/&gt;
        &lt;include within="akka.dispatch.*"/&gt;
        &lt;include within="scala.concurrent.*"/&gt;
        &lt;include within="java.util.concurrent.*"/&gt;
    &lt;/weaver&gt;
&lt;/aspectj&gt;
          </code></pre>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <pre><code data-trim class="java">
public aspect ActorCellMonitoringAspect {

  Object around(ActorCell actorCell, Object msg) : 
    call(* a.a.ActorCell.receiveMessage(..)) 
    &amp;&amp; args(msg) &amp;&amp; target(actorCell) {
      // check configuration to see if we're interested
      // publish 'delivered' events
      // measuring performance
      Object result = proceed(actorCell, msg);
      // return null would do, but we are _proper_.
      return result;
  }
}
          </code></pre>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <pre><code data-trim class="java">
public aspect DispatcherMonitoringAspect {

  before(ExecutorService es) : 
    call(* j.u.c.ExecutorService+.execute(..)) 
    &amp;&amp; target(es) {
      // publish 'active threads' count
      // publish 'running threads' count
    }

}
          </code></pre>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <p>The aspects need configuration for the <em>agent</em>s and <em>output</em>s.</p>
          <ul>
            <li>Decide which actors to monitor</li>
            <li>How to aggregate the monitoring data</li>
            <li>How to deliver the monitoring data</li>
          </ul>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <p>Typesafe Config-style files at known locations configure the agent and output modules.</p>
          <ul>
            <li><code>/META&ndash;INF/monitor/agent.conf</code> for the agent</li>
            <li><code>/META&ndash;INF/monitor/output.conf</code> for the output</li>
          </ul>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.agent {
  output.class: "org...StatsdCounterInterface"

  akka {
    included: [
      "akka:default.org...SimpleActor",
      "akka://default/user/x"
    ]
    sampling: [
      { rate: 5, for: [ "akka://default/user/*" ] }
    ]
  }
}          
          </code></pre>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.output.statsd {
    prefix: ""
    remoteAddress: "localhost"
    remotePort: 8125
    refresh: 5
    initialDelay: 5
    constantTags: []
}
          </code></pre>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.output.codahalemetrics {
    registry-class: "org...DefaultRegistryProvider"
    naming-class:   "org...DefaultNameMarshaller"
    prefix: ""
    refresh: 5
}
          </code></pre>
        </section>

        <section data-background="images/output.jpg">
          <h2>Output modules</h2>
          <p>The aspects load configurable output modules. Our client needed statsd / DataDog, but we have two more!</p>
          <ul>
            <li>statsd (with <a href="http://www.datadoghq.com/" target="_blank">Datadog</a> extensions)</li>
            <li>dtrace (on Solaris, dummy elsewhere)</li>
            <li>Codahale Metrics</li>
          </ul>
        </section>

        <section data-background="images/output.jpg">
          <h2>Statsd</h2>
          <p>What is it?</p>
          <pre><code data-trim class="java">
UDP : ...
          </code></pre>
        </section>

        <section data-background="images/output.jpg">
          <h2>dtrace</h2>
          <p>What is it?</p>
          <pre><code data-trim class="java">
UDP : ...
          </code></pre>
        </section>

        <section data-background="images/output.jpg">
          <h2>Codahale Metrics</h2>
          <p>What is it?</p>
          <pre><code data-trim class="java">
UDP : ...
          </code></pre>
        </section>

        <section data-background="images/production.jpg">
          <h2>Into the battle!</h2>
          <ul>
            <li>Dependencies for the agents and output modules you require
              <pre><code data-trim class="scala">
"org.eigengo.monitor" %% "agent-akka"    % "0.4",
"org.eigengo.monitor" %% "output-statsd" % "0.4"
              </code></pre>
            </li>
            <li>Agent configuration in <code>/META-INF/monitor/agent.conf</code><br/>
              and—if required—<br/>
              Output configuration in <code>/META-INF/monitor/output.conf</code></li>
            <li><code>/META-INF/aop.xml</code> to give configuration to the weaver</li>
          </ul>
        </section>

        <section data-background="images/production.jpg">
          <h2>Was it OK?</h2>
          <p>What have we found?</p>
        </section>

        <!-- demo -->
        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Adding monitoring to some existing Akka application. See DD integration.</p>
        </section>
        
        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Adding monitoring to some existing Akka application. See DD integration.</p>
        </section>

        <section>
          <h2>War stories?</h2>
          <p>What have we learned in building large Akka system?</p>
          <p>What have we learned in building the Reactive Monitor?</p>
        </section>

        <section>
          <h2>Thank you!</h2>
          <ul>
            <li>Source at <a href="https://github.com/eigengo/monitor">github.com/eigengo/monitor</a></li>
            <li>Slides at <a href="http://www.eigengo.com/monitoring-akka-play">www.eigengo.com/monitoring-akka-play</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a> | <a href="https://twitter.com/alexlashford">@alexlashford</a></li>
          </ul>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
