<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Tuning Akka</title>
    <meta name="description" content="Tuning Akka">
    <meta name="author" content="Jan Machacek, Alex Lashford">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-background="images/akkadays.jpg">
          <h1>Tuning Akka</h1>
          <h3>With a dose of idealism and realism</h3>
          <p>
            <small>
              Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a>&nbsp;&nbsp;|&nbsp;&nbsp;
              Alex Lashford <a href="https://twitter.com/alexlashford">@alexlashford</a>
            </small>
          </p>
        </section>

        <section data-background="images/success-baby.jpg">
          <h2>Congratulations! You've made it!</h2>
          <p>The users love your system - interactions increase </p>
          <p>100's -> 1000's -> 10,000's of users</p>
          <p>And you <em>worry</em>.</p>
          <aside class="notes">
            <p>So Akka is 5 years old, it's a fantastic framework which gives us the toolset to create Scalable / Event Drivien applications.  Hopefully these applications will follow the core principles of the Reactice Manefesto, but what happens when you have created the next Netflix? Unfortunatly, Akka does not solve all of the woes of running in production, it is not a silver bullet, you still need to keep an eye on your stack and follow key principles during your development.</p>
            <p>In our talk we are going to run through some of the Basics of "Akka in Production" and hopefully give you some tips & tricks as you embark on your Production journey.</p>
            <p>So the question is, are you ready for production?  We will revisit this question later but before we do, lets take a look at the basics.</p>
          </aside>
        </section>

        <section data-background="images/basics.jpg">
          <h2>The basics</h2>
          <ul>
            <li>Event-driven</li>
            <li>Scalable</li>
          </ul>
          <aside class="notes">
            <p>You got the basics right. You are event-driven. Events (in Akka, think messages delivered to <code>ActorRef</code>s) are <em>not really inconvenient &amp; clunky method calls</em>, you treat them as truly asynchronous events that can arrive at any point, and your system must react to them.</p>
            <p>All this helps scalability. If one designs a system whose components are loosely-coupled and communicate throgh messages, it becomes easy to scale such system by simply adding processing nodes. The nodes could be CPU cores, JVMs, network nodes, sets of nodes in a different network region, ...</p>
          </aside>
        </section>

        <section data-background="images/basics.jpg">
          <h2>The basics</h2>
          <ul>
            <li>Defined supervisor strategies</li>
            <li>When creating actors, set the dispatcher, router and mailbox</li>
            <li>Your actors form hierarchies, and you have only a few top-level actors</li>
            <li>You do not allow actor's state to escape</li>
          </ul>
          <aside class="notes">
            <p>You must have supervisor strategies, otherwise, you have no hope of being resilient.</p>
            <p>The configuration for the actors (mailboxes, routers, dispatchers, ...) is configured in a well-known place. If the actor configuration needs some logic, have it all in code; if the configuration requires no logic at all, keep it in the configuration file. But do not mix the approaches. <code>system.actorOf(Props[FooActor])</code> is almost always bad.</p>
            <p>The top-level actors are not part of any supervision chain that you control. If the top-level actor fails, the entire system fails.</p>
            <p>It is often tempting to send back a function that closes over the state as the response from an actor, but that is <em>always</em> a terrible idea. (Ignoring for now the problem of sending the closed-over variables and the function to some <em>remote</em> actor, this sort of horror immediately puts you back into the raw Java concurrency world.)</p>
          </aside>
        </section>

        <section data-background="images/tuning.jpg">
          <h2>Tune to achieve</h2>
          <p>You are <em>event-driven</em> and therefore more easily <em>scalable</em>. You are using Akka <em>properly</em>, so you just need to tweak some settings to achive the best <em>responsiveness</em> and <em>resilience</em>.</p>
          <aside class="notes">
            <p>Assuming your code follows our previous slides—that is:
            <ul>
              <li>you have proper actor hierarchy, with supervisor strategies at the appropriate level giving resilience</li>
              <li>the <code>Props</code> for the actors always set the dispatcher, router, and mailbox</li>
              <li>you do not let [mutable] state escape</li>
            </ul>
            Then your job is to ensure that you configure the dispatchers, routers and mailboxes appropriately for the type of load that your application is expected to handle.</p>
            <p>Even better, as we'll explore later on, you will instrument your application so that you <em>know</em> instead of <em>think</em> what your application is actually doing.</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>Mailboxes, dispatchers and routers</h2>
          <ul>
            <li>Dispatchers execute arbitrary code</li>
            <li>Mailbox holds the messages for an actor</li>
            <li>Routers allow a number of actors to process the incoming messages</li>
          </ul>
          <aside class="notes">
            <p>In the Akka world, the dispatchers define the mailbox sharing strategy, and schedule the delivery of the messages between the actors. We have four dispatchers baked into Akka.</p>
            <ul>
              <li>Dispatcher sets each actor with its own mailbox; shareable; backed by thread pool or F-J pool. Optimised for non-blocking code.</li>
              <li>Pinned dispatcher sets each actor with its own mailbox; non-shareable—creates dedicated thread for each actor; backed by thread pool; optimised for blocking or CPU-bound operations</li>
              <li>Balancing dispatcher sets one mailbox for all actors; shareable by actors of the same kind; backed by thead pool or Fork-Join pool</li>
            </li>
            <p>Mailbox holds the messages delivered to the actor. The dispatcher decides how actors share the mailbox, delivers the message to the mailbox, and schedules the actor's <code>receive</code> function.</p>
            <p>Router manages and maintains its routees. The dispatcher delivers a message to the router, and depending on the routing strategy, it decides how to deliver it to one of its routees. The strategies are:
            <ul>
              <li>Round robin router</li>
              <li>Random</li>
              <li>Smallest mailbox</li>
              <li>Broadcast</li>
              <li>Scatter, gather first completed</li>
            </ul>
            </p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>Classes of problems</h2>
          <ul>
            <li>Number or string crunching</li>
            <li>I/O</li>
            <li>Memory</li>
          </ul>
          <aside class="notes">
            <p>So before you can make the right choices about configuration of the Actor system, you need to understand and classify the types of problems. Then ultimatly use the appropriate config to instruct Akka on how to best deal with that classifaction of problem.</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>Number or string crunching</h2>
          <ul>
            <li>Consumes the thread</li>
            <li>Avoid context switching</li>
            <li>Set the number of threads in the pool to match your cores</li>
          </ul>
          <aside class="notes">
            <p>This is typically CPU-bound work. There is no point in attempting to be somehow non-blocking: the CPU is be busy performing the computation, it cannot do the work in the background, and then send a message back when it's done.</p>
          	<p>Use the <code>PinnedDispatcher</code> backed by reasonably-sized thread pool. Remember CPU-bound work feels like blocking I/O; but it actually keeps the CPU hot. You want to avoid context switches, you want to keep the caches hot, prevent the CPU from entering sleep states, ...</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>I/O</h2>
          <ul>
            <li>Favour non-blocking APIs</li>
            <li>Be aware of back-pressure</li>
            <li>Carefully configure timeouts and remember to react to errors</li>
            <li>If you must use blocking calls, bulkhead them</li>
          </ul>
          <aside class="notes">
            <p>Non-blocking APIs are not a golden hammer: you cannot just think "I'm using non-blocking APIs, therefore I'm safe". To be flippant, why do you think say a network interface comes with a silly specification like <em>1 Gbps</em>? It means that you should never feed it more than 1 Gbps. To be sure, your userspace program will probably be fine for a bit, but the kernel will have more and more work dealing with the unexpeced load. With non-blocking APIs, you must be aware of the back-pressure.</p>
            <p>Back-pressure is a mechanism that allows the downstream components to drive the flow of data. The concept (in Reactive Streams) is that the downstream components must explicitly ask for more data from the upstrem components. </p>
            <p>If the downstream guys are feeling confident, they can easily request <code>Int.MaxValue</code> values, and then it's up to the upstream guys to satisfy the demand. 
            <br/>
            If the downstream components are super-cautious, they will only ask for one element at a time; and the upstream components must comply with the demand.</p>
            <p>If you are using non-blocking APIs appropriately (with back-pressure), be sure to configure and use appropriate timeouts and react to error conditions. Remember, the errors will come later, perhaps on some other thread. Same applies to timeouts: if your users are expecting a response in 2 seconds, it is useless to have 60 second timeout on some HTTP call that you're making to satisfy the user's request.</p>
            <p>Finally, if you are using blocking calls, be sure to separate them  in separate <code>Future</code>s, <code>Actor</code>s, or even <code>ActorSystem</code>s—ultimately—threads. Your actors <em>cannot</em> block, otherwise you are risking the health of the entire actor system.</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>Memory</h2>
          <ul>
            <li>Use bounded mailboxes (<code>BoundedMailbox</code>, <code>BoundedPriorityMailbox</code>, <code>BoundedControlAwareMailbox</code>)</li>
            <li>If your actor behaviour is processing a lot of data, consider using off-heap structures (think <code>ByteBuffer.allocateDirect(Int.MaxValue)</code></li>
            <li>Memory / GC pressure will make your application die with a whimper, not a bang</li>
          </ul>
          <aside class="notes">
            <p>If your application generates too much pressure on the GC, the performance will degrade, but there is nothing you will be able to do about it. In extreme—or simply naive—cases, you can make your application appear completely frozen just by sending your actors too many messages.</p>
            <p>First off, and this applies to any production-ready Akka system, always use bounded mailboxes. If you do not, it is possible to kill your actor system by forcing an <code>OutOfMemoryError</code> or to generate so much GC pressure that the application will become completely unresponsive and spend all time in GC.</p>
            <p>For example, it is much faster to allocate 2GiB off-heap, and then manage the memory layout yourself. Think some big-data analysis.</p>
          </aside>
        </section>

        <section data-background="images/notideal1.jpg">
          <h2>Sometimes things aren't ideal</h2>
          <p><em>Your code</em> is reactive and tuned, reality brings things that are:</p>
          <ul>
            <li>not responsive</li>
            <li>not resilient</li>
            <li>not scalable</li>
          </ul>
          <aside class="notes">
            <p>Here, we mean integratation with libraries that block threads; that—once they fail, they keep failing; services that you know (or suspect) are not scalable.</p>
            <ul>
            <li>not responsive &rarr; bulkhead thread-pools and executors</li>
            <li>not resilient &rarr; bulkhead failures, define good supervisor strategies</li>
            <li>not scalable &rarr; implement flow control / back pressure reporting or a hard circuit-breaker</li>
            </ul>
            <p>It would be nice to be able to make all of this reactive, but sometimes, you have to pick your battles. And so, rather than trying to fix the world, an easier way is to isolate the problematic areas, and to <em>try to be nice</em> to services that cannot keep up with your system.</p>
            <p>Think how important the concept of <em>back pressure</em> is! It is far better for your system to know what its dependencies can cope with, than deal with sudden failures, or to have a hard circuit-breaker.</p>
          </aside>
        </section>

        <section data-background="images/notideal1.jpg">
          <h2><strike>Responsive</strike></h2>
          <p>Blocking. Describe symptoms. Show snippet of code.</p>
        </section>

        <section data-background="images/notideal1.jpg">
          <h2><strike>Responsive</strike></h2>
          <p>Show solution &amp; tuning approach for the specific snippet</p>
        </section>

        <section data-background="images/notideal1.jpg">
          <h2><strike>Responsive</strike></h2>
          <p>Generalise</p>
        </section>

        <section data-background="images/notideal2.jpg">
          <h2><strike>Resilient</strike></h2>
          <p>Fails dramatically, failures spread / persist. Describe symptoms. Show snippet of code.</p>
        </section>

        <section data-background="images/notideal2.jpg">
          <h2><strike>Resilient</strike></h2>
          <p>Show solution &amp; tuning approach for the specific snippet</p>
        </section>

        <section data-background="images/notideal2.jpg">
          <h2><strike>Resilient</strike></h2>
          <p>Generalise</p>
        </section>

        <section data-background="images/notideal3.png">
          <h2><strike>Scalable</strike></h2>
          <p>Throttle / flow control / circuit breaker. Describe symptoms. Show snippet of code.</p>
        </section>

        <section data-background="images/notideal3.png">
          <h2><strike>Scalable</strike></h2>
          <p>Solution for the specific scenario.</p>
        </section>

        <section data-background="images/notideal3.png">
          <h2><strike>Scalable</strike></h2>
          <p>Generalise.</p>
        </section>

        <section data-background="images/sinking_ship.jpg">
          <h2>Bulkheading</h2>
          <p><em>Divide</em> your application not only by functional area, but by classifaction of the problem</p>
          <br/>
          <h2>Backpressure</h2>
          <p>It is far better for your system to know what its dependencies can cope with, than to deal with the <em>big bang!</em></p>
          <aside class="notes">
            <p>Two common themes we have touched on here is Bulkheading & Backpressure</p>
            <ul>
            <p>Bulkheading</p>
            <li>This principle comes from ship building, where you would typically Bulkhead (divide) parts of the hull.  The aim to prevent the hole ship sinking due to damage in a section of the hull.   You can easily see this idea is easily applied to the architecture of an Akka application where you need to isolate the CPU intensive from the blocking IO, so not bring the hole application to a standstill. </li>
            <p>Back-pressure</p>
            <li>It is far better for your system to know what its dependencies can cope with, than to deal with the <em>big bang!</em>, encapsulate the slowness and allow that function to self-regulate its consumption rate.</li>
            </ul>
          </aside>
        </section>

        <!-- Monitoring -->
        <section data-background="images/everythingfine.jpg">
          <h2>So, tell me again</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>how everything's fine in production!</h2>
          <aside class="notes">
            <p>What is happening <em>inside</em> your application?</p>
            <p>we should be looking to lift the lid on our apps and shine the light on this Black box to get us some much needed visibility.  
            <ul>
              <li>Do we have any hotspots in our actor system?</li>
              <li>Are the message queues getting too big? (Are the messages spending too much time in the queues?) </li>
              <li>Is the 'mean' time in on-receive too high</li>
              <li>Do we have enough threads, and are those threads being blocked, utilised efficently?</li>
            </ul>
              Monitoring gives an insight into the performance and flow of an application,
              allowing us see hotspots, and areas of poor performance: increasing our visibility to what is occuring.
              The aim is 24/7 uptime, preventing the big boom! How do you know that something's broken in time to do something about it? It is insufficient to monitor HTTP 500s, we want to have time to react before the 500s.
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Monitor</h2>
          <p>Record <em>just enough</em> information. Too much slows down the monitored system, too little lets events go unnoticed.</p>
          <p>&nbsp;</p>
          <ul>
            <li>Actor creation &amp; destruction.</li>
            <li>Message types, message rates, failures and performance at the actor level</li>
            <li>Queue size at the (local) actor level</li>
            <li>The number of available and running threads in the <code>ThreadPool</code>s</li>
          </ul>
          <aside class="notes">
            <p>Do not allow the monitoring tool to bring down the application; use light-weight montioring message delivery mechanisms.</p>
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Monitoring Options</h2>
          <p>Typesafe Console<pre>- Dev focused montioring</pre></p>
          <p>Reactive Monitor<pre>- Lightweight, Configurable, OpenSource</pre><</p>
          <p>Kamon.io<pre>- Akka based, statsd / graphite inetgrations</pre></p>
          <aside>
            <p>So for monitoring your akka application you have a few of options</p>
            <ul>
              <li>Typesafe Console - aimed at Development rather than prduction but can provide improved visibility for your devs.</li>
              <li>Reactive Monitor - Lightweight, configurable, muliple integrations, open source and improvements welcome.</li>
              <li>Kamon - gaining populatrity, muliple integrations also Aspect based.</li>
            </ul>
             <p>We liked the Typesafe Console, but we needed an alternative solution for the client in Production. So, we scratched our own itch, and made the open source Reactive Monitor. Instead of targetting <em>only</em> statsd (with Datadog), we split the agents and the outputs.</p>
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>candidate for DELETION!</h2>
            <h2>Typesafe Console!</h2>
          <img src="images/console.png"/>
          <aside class="notes">
            <p>Typesafe Console! It looks great, and it gives in-depth stats on the actor system. But... we promised we won't be party poopers, and so, let's talk about something else.</p>
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>candidate for DELETION!</h2>
          <h2>Statsd</h2>
          <p>Most statsd tools can show very pretty charts.</p>
          <img src="images/datadog.png"/>
          <aside class="notes">
            <p>There are plenty of tools that can listen for the statsd datagrams, and analyse the data. Typically, they have pretty user interfaces, charts, alerts, ...</p>
          </aside>
        </section>

        <section data-background="images/mementomori.jpg">
          <h2>Remember!</h2>
          <ul>
            <li>Be reactive, isolate the non-reactive components</li>
            <li>Measure and then measure again, do not guess</li>
            <li>Find out how your application breaks under extreme load</li>
          </ul>
          <aside class="notes">
            <p><em>Finis coronat opus!</em>—the end crowns the work</p>
            <p>Remember: be event-driven, which helps scalability. Then ensure that you remain responsive through non-blocking APIs and bulkheading of blocking calls, take care of back-pressure and memory-pressure. Use your system's hierarchy: actors, entire JVMs, clusters of JVMs to provide reslience. It is better to go out with a bang (think <code>System.exit(-1)</code> than whimper along)</p>
            <p>Remember: The "Akka 101" applications don't provide production-ready configuration or style</p>
            <p>Remember: Good observation is good science. You want to come home and say to your partner that you've been <em>doing really complicated science all day at work</em>!</p>
          </aside>
        </section>

        <section data-background="images/devops.jpg">
          <h2>Thank you!</h2>
          <ul>
            <li>Slides at <a href="http://www.eigengo.com/tuning-akka">www.eigengo.com/tuning-akka</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a> | <a href="https://twitter.com/alexlashford">@alexlashford</a></li>
          </ul>
          <hr/>
          <p><big>Law of Murphy for devops: if thing can able go wrong, is mean is already wrong but you not have Nagios alert of it yet.</big></p>
        </section>
        
        <!-- Production ready?
        <section data-background="images/fineindev.jpg">
          <h2>Worked fine in dev—ops problem now!</h2>
          <p>We create actor systems in Akka (perhaps with REST APIs in Spray); modern web applications in Play, and we all like to think that these applications will attract <strike>thousands</strike> billions of users.</p>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>What to Monitor</h2>
          <p>You want to see inside the Akka, Play Framework or Spray and know what is happening in the system's components.</p>
          <p>&nbsp;</p>
          <ul>
            <li>Number / rates of messages</li>
            <li>Sizes of queues</li>
            <li>Duration of messages in queue</li>
            <li>Time it takes to execute the <code>receive</code> PF</li>
            <li>Number / rates of failures</li>
            <li>The threads in the thread pools</li>
          </ul>
           <aside class="notes">
             What metrics do you want to see, when the app is in production. 

             During our consultancy, customers often complain that actors are black boxes. It is difficult to understand what the application is doing; especially if they come from a traditional JEE background.
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Typesafe Console!</h2>
          <img src="images/console.png"/>
          <aside class="notes">
            Typesafe Console! It looks great, and it gives in-depth stats on the actor system.
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Typesafe Console!</h2>
          <p>Brilliant, looks great, under low load its really impressive. We loved it, but ...</p>
          <p>&nbsp;</p>
          <ul>
            <li>Production—unusable: too much data, memory usage, I/O</li>
            <li>Development—great: gives in–depth view of the actor system</li>
          </ul>
          <aside class="notes">
            But it records too much data and just eats resource when doing performance tests. 
            In summary:
            * production is a no go
            * development is recomended, great for tracing the flow through the actor system. 
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Reactive Monitor</h2>
          <p>We wanted to record <em>just enough</em> information. Too much slows down the monitored system, too little lets events go unnoticed.</p>
          <p>And we wanted to have a flexible mechanism to deliver the collected monitoring information.</p>
          <p>&nbsp;</p>
          <ul>
            <li>Actor creation &amp; destruction.</li>
            <li>Message types, message rates, failures and performance at the actor level</li>
            <li>Queue size at the (local) actor level</li>
            <li>The number of available and running threads in the <code>ThreadPool</code>s</li>
          </ul>
          <aside class="notes">
            We liked the Typesafe Console, but we needed an alternative solution for the client. So, we scratched our own itch, and made the open source Reactive Monitor. Instead of targetting <em>only</em> statsd (with Datadog), we split the agents and the outputs.
            At the highest level, the architecture is:
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Reactive Monitor</h2>
          <img src="images/architecture.png"/>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
val system = ActorSystem()
val x = system.actorOf(Props[XActor])
val y = system.actorOf(Props[YActor])
x ! "foo"
y ! "foo"
y ! 42
          </code></pre>
          <aside class="notes">
            With this code, what sort of metrics can you get with our monitoring tool?
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
x ! "foo"; y ! "foo"; y ! 42
          </code></pre>
          <img src="images/chart.png"/>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>We monitor</h2>
          <pre><code data-trim class="scala">
val system = ActorSystem()
val x = system.actorOf(Props[XActor])
val y = system.actorOf(Props[YActor])
x ! "foo"
y ! "foo"
y ! 42
          </code></pre>
          <aside class="notes">
            Remember, we do not want to have to modify our source code, nor do we want to maintain a custom
            fork of Akka, Play, Spray, ...!

            You source code stays the same...
          </aside>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <p>It allows us to instrument Akka's and Play's bytecode as it is loaded by the <code>ClassLoader</code>s. We can do 
            <em>anything</em> we like, as long as the instrumented bytecode verifies. </p>
          <img src="images/ltw.png"/> 
          <aside class="notes">
            This is how we apply the agents into the application being monitored. We used AspectJ LTW to monkey-patch Akka's, Spray's and Play's JARs. This means that there are no custom builds of Akka, Spray or Play!
          </aside>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <p>To <em>turn on</em> LTW, set the <code>-javaagent</code> JVM parameter, and add <code>/META-INF/aop.xml</code>.</p>
          <pre><code data-trim class="xml">
&lt;aspectj&gt;
    &lt;aspects&gt;
        &lt;aspect name="ActorCellMonitoringAspect"/&gt;
        &lt;aspect name="DispatcherMonitoringAspect"/&gt;
    &lt;/aspects&gt;
    &lt;weaver options="-verbose -showWeaveInfo"&gt;
        &lt;include within="akka.actor.*"/&gt;
        &lt;include within="akka.dispatch.*"/&gt;
        &lt;include within="scala.concurrent.*"/&gt;
        &lt;include within="java.util.concurrent.*"/&gt;
    &lt;/weaver&gt;
&lt;/aspectj&gt;
          </code></pre>
          <aside class="notes">
            aop.xml tells the weaver where to unleash its monkey-patching magic. In other words, we restrict the scope of the work that the weaver has to do.
          </aside>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <pre><code data-trim class="java">
public aspect ActorCellMonitoringAspect {

  Object around(ActorCell actorCell, Object msg) : 
    call(* a.a.ActorCell.receiveMessage(..)) 
    &amp;&amp; args(msg) &amp;&amp; target(actorCell) {
      // check configuration to see if we're interested
      // publish 'delivered' events
      // measuring performance
      Object result = proceed(actorCell, msg);
      // return null would do, but we are _proper_.
      return result;
  }
}
          </code></pre>
        </section>

        <section data-background="images/aspectj.jpg">
          <h2>AspectJ</h2>
          <pre><code data-trim class="java">
public aspect DispatcherMonitoringAspect {

  before(ExecutorService es) : 
    call(* j.u.c.ExecutorService+.execute(..)) 
    &amp;&amp; target(es) {
      // publish 'active threads' count
      // publish 'running threads' count
    }

}
          </code></pre>
        </section>

        <section data-background="images/agent.jpg">
          <h2>Agents</h2>
          <ul>
            <li><strong>Akka</strong> - measuring actor instances, their performance, failures, messages, message queues and threads</li>
            <li><strong>Spray</strong> - measuring the HTTP requests, and bytes transferred</li>
            <li><strong>Play</strong> - measuring the HTTP requests, controller performance and failures</li>
          </ul>
          <aside class="notes">
            <p>Nota bene that Spray is based on Akka, so the I/O traffic is <em>in addition</em> to everything that the Akka agent measures</p>
            <p>The agents are essentially a collection of aspects that instrument the interesting methods in their target, and report the information they collected to the configured <em>output</em> module.</p>
          </aside>
        </section>

        <section data-background="images/agent.jpg">
          <h2>Akka Agent</h2>
          <p>We have some specific instrumenation around some of the useful intractions in the Akka framework, including support for both the Java and Scala APIs</p>
          <p>&nbsp;</p>
          <ul>
            <li>Actor instances</li>
            <li>Time in <code>receive</code> / <code>onRecieve(Object)</code></li>
            <li>Mailbox size</li>
            <li>Message time in mailbox</li>
            <li>Exceptions</li>
            <li>Executor / Thread data</li>
          </ul>
          <aside class="notes">
            <p>instrumentation around specific akka interactions, i,e  Actor Count, Avg OnRecieve ...</p>
          </aside>
        </section>

         <section data-background="images/agent.jpg">
          <h2>Play Framework Agent</h2>
          <p>Instrumenation around some of the useful intractions in the Play Framework, including support for both the Java and Scala APIs</p>
          <p>&nbsp;</p>
          <ul>
            <li>HTTP requests (grouped by route)</li>
            <li>Exceptions</li>
          </ul>
          <aside class="notes">
            <p>instrumentation around specific Play interactions, i,e  Request Count grouped by Route / Path, Error / Exception count...</p>
          </aside>
        </section>

         <section data-background="images/agent.jpg">
          <h2>Spray Agent</h2>
          <p>Provides instrumenation for the Spray libraries</p>
          <p>&nbsp;</p>
          <ul>
            <li>HTTP requests</li>
            <li>Overall request processing time</li>
            <li>Marshaller / unmarshaller performance</li>
            <li>Bytes transferred</li>
          </ul>
          <aside class="notes">
            <p>Provide the hooks and instrumenation around around the spray Api, i,e  Request Count grouped by Route / Path, Error / Exception count.  in addtiion to all the metrics you get with the Akka agent...</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Output modules</h2>
          <p>The aspects load configurable output modules. We scratched our own itch by implementing the statsd / Datadog output module, but we have two more!</p>
          <p>&nbsp;</p>
          <ul>
            <li>statsd (with <a href="http://www.datadoghq.com/" target="_blank">Datadog</a> extensions)</li>
            <li>DTrace (on Solaris, dummy elsewhere)</li>
            <li>Codahale Metrics</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Statsd</h2>
          <p>Really simple transport: strings up to 508 bytes long over UDP.</p>
          <pre><code data-trim>
aspect ':' value '|' type '|#' tag1 ',' tag2 ',' ...
          </code></pre>
          <p>For example, in our application</p>
          <pre><code data-trim class="no-highlight">
akka.actor.delivered:50|c|#↩
  akka://default/user/x,akka.type:default.org...XActor
akka.actor.delivered.Integer:50|c|#↩
  akka://default/user/x,akka.type:default.org...XActor
akka.actor.duration:99|ms|#↩
  akka://default/user/x,akka.type:default.org...XActor
          </code></pre>
          <aside class="notes">
            <p>statsd is a light-weight UDP-based protocol to send tracing information to anything that can understand the datagrams. The datagrams carry specifically-formatted strings. Hence Datadog (and others) can offer extensions to the standard stasd formats easily.</p>
            <p>The <code>type</code> can be either 'c' for count—increments and decrements, 'g' for gauge—absolute value, and 'ms' for execution time.</p>
            <p>We can get away with this—the minimum MTU on the internet is 576, the size of the IPv4 header at most 60 bytes, and the UDP header 8 bytes. This leaves 508 bytes available for the monitoring data.</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Statsd</h2>
          <p>Most statsd tools can show very pretty charts.</p>
          <img src="images/datadog.png"/>
          <aside class="notes">
            <p>There are plenty of tools that can listen for the statsd datagrams, and analyse the data. Typically, they have pretty user interfaces, charts, alerts, ...</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Statsd</h2>
          <pre><code data-trim class="scala">
class StatsdActor(remote: InetSocketAddress, 
                  prefix: String) extends Actor {
  IO(Udp) ! Udp.SimpleSender
  def receive: Receive = {
    case Udp.SimpleSenderReady =>
      context.become(ready(sender))
  }
  def ready(send: ActorRef): Receive = {
    case stat: StatsdStatistic =>
      val payload = toByteString(stat, prefix)
      send ! Udp.Send(payload, remote)
  }
}
          </code></pre>
          <aside class="notes">
            <p>In keeping with the asynchronous approach, the I/O that this output module produces is isolated in its own <code>ActorSystem</code>. This means that the output module has as little impact on your application as possible.</p>
            <p>its also note worthy that the datagrams are sent over UDP so even at a low level there is no blocking as the Ststad client is not waiting for an ack of the message.</p>
            <p>so in summary, Statsd is lightwieght, simple first impl was only 137 lines long, widly supported, DataDog, Graphite etc.</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>DTrace</h2>
          <p>DTrace is kernel-level, production-ready, minimal-impact tracing mechanism.</p>
          <pre><code data-trim class="bash">
$ sudo dtrace -l
ID   PROVIDER            MODULE     NAME
 1     dtrace                       BEGIN
 2     dtrace                       END
 3     dtrace                       ERROR
 4 nfsmapid804          nfsmapid    daemon-domain
 5 kerberos800    mech_krb5.so.1    krb_ap_rep-make
   ...
33 akka2083         java_tracing    all-gauges
34 akka2083         java_tracing    execution-time
35 akka2083         java_tracing    all-counters          
          </code></pre>
          <aside class="notes">
            <p>There are ports of DTrace from Solaris to Linux, NetBSD and others. Reactive Monitor adds probes using JVM's tracing APIs, and even though for example OS X includes dtrace, the JVM on OS X does not "talk" to dtrace.</p>
            <p>DTrace's <em>probes</em> are roughly comparable to pointcuts: that is, they point to a specific location in execution flow. When the execution hits the probe, it fires.</p>
            <p>One writes D programs that attach to the firing probes and execute C-like code. In the bodies of the probes, you can do arbitrary operations. Imagine, for example, being able to automatically modify the zone's CPUs, memory, and so on! In fact, this is what we're working on with Joyent. So go ahead and take a peek!</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>DTrace</h2>
          <p>The actual interface relies on the <em>internal</em> tracing API that the Oracle JDK and OpenJDK provides.</p>
          <pre><code data-trim class="java">
@ProviderName("akka")
public interface DtraceCounterProvider 
    extends com.sun.tracing.Provider {

    @FunctionName("Receive execution time")
    @ProbeName("execution-time")
    void executionTime(String name, int length, 
                       int duration);

    ...
}
          </code></pre>
          <aside class="notes">
            <p>The annotations and the <code>Provider</code> interface itself are internal APIs; also notice that we have to be careful when sending the <code>String</code>s, and include the string's length and be sure that the character encoding is known. This will all become really important when we take a look at the D script that follows.</p>
            <p>We then use JDK's tracing provider to get a JDK proxy that conforms to our interface, that—on Solaris—creates the DTrace entries when we call the interface's methods. Outside Solaris, we get a dummy implementation of this interface. We tried this on latest OS X, latest Ubunbu, latest CentOS, and Solaris 11; all with Oracle's JDK, and OpenJDK on OS X.</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>DTrace</h2>
          <p>The D program needs to copy in data from kernel space to the user space where the program runs.</p>
          <pre><code data-trim class="D">
akka$1:::exeucution-time {
  printf("execution time: %s -> %d", 
    stringof(copyin(arg0, arg1 + 1)), arg2);
}

akka$1:::all-counters {
  printf("counter: %s -> %d", 
    stringof(copyin(arg0, arg1 + 1)), arg2);
}
          </code></pre>
          <pre><code data-trim class="bash">
$ sudo dtrace -s script.d `pgrep java`
          </code></pre>
          <aside class="notes">
            <p>Notice in particular the <code>copyin</code> and <code>stringof</code> calls. The first one deals with copying kernel memory from the pointer <code>arg0</code>, taking <code>arg1</code> bytes. This is exactly the place where one needs to be aware of string encoding (anyone fancies using unicode names for actor names?)</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Codahale Metrics</h2>
          <p>A metrics library in Java (and Scala) that allows us to deliver measurement types similar to 
          what statsd can do.</p>
          <p>Unlike statsd, Metrics is the entire monitoing framework. It processes the information it receives, performs
          the calculations we want, and exposes the measurements.</p>
          <aside class="notes">
            <p>It can expose the data using Ganglia (!!), statsd (!!), console, CSV, JMX, HTTP; all that you have to do is to bring in the specific dependencies, in addition to the <code>output-codahalemetris</code> module from Reactive Monitor</p>
          </aside>
        </section>

        <section data-background="images/output.jpg">
          <h2>Codahale Metrics</h2>
          <pre><code data-trim class="scala">
class MetricsCounterInterface 
  extends CounterInterface with MetricsHandler {

  def registry: MetricRegistry = ...
  def marshaller: NameMarshaller = ...

  def recordExecutionTime(aspect: String, 
                          duration: Int, 
                          tags: String*): Unit =
    updateExecutionTime(aspect, duration, tags)
  
  ...
}
          </code></pre>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <p>The aspects need configuration for the <em>agent</em>s and <em>output</em>s.</p>
          <p>&nbsp;</p>
          <ul>
            <li>Decide which actors to monitor</li>
            <li>How to aggregate the monitoring data</li>
            <li>How to deliver the monitoring data</li>
          </ul>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <p>Typesafe Config-style files at well-known locations configure the agent and output modules.</p>
          <p>&nbsp;</p>
          <ul>
            <li><code>/META-INF/monitor/agent.conf</code> for the agent</li>
            <li><code>/META-INF/monitor/output.conf</code> for the output</li>
          </ul>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.agent {
  output.class: "org...StatsdCounterInterface"

  akka {
    included: [
      "akka:default.org...SimpleActor",
      "akka://default/user/x"
    ]
    sampling: [
      { rate: 5, for: [ "akka://default/user/*" ] }
    ]
  }
}          
          </code></pre>
        </section>

        <section data-background="images/configuration.jpg">
          <h2>Configuration</h2>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.output.statsd {
    prefix: ""
    remoteAddress: "localhost"
    remotePort: 8125
    refresh: 5
    initialDelay: 5
    constantTags: []
}
          </code></pre>
          <pre><code data-trim class="javascript">
org.eigengo.monitor.output.codahalemetrics {
    registry-class: "org...DefaultRegistryProvider"
    naming-class:   "org...DefaultNameMarshaller"
    prefix: ""
    refresh: 5
}
          </code></pre>
        </section>

        <section data-background="images/angrymob.jpg">
          <h2>Into the battle!</h2>
          <ul>
            <li>Dependencies for the agents and output modules you require
              <pre><code data-trim class="scala">
"org.eigengo.monitor" % "agent-akka"    % "0.4",
"org.eigengo.monitor" % "output-statsd" % "0.4"
              </code></pre>
            </li>
            <li>Agent configuration in <code>/META-INF/monitor/agent.conf</code><br/>
              and—if required—<br/>
              Output configuration in <code>/META-INF/monitor/output.conf</code></li>
            <li><code>/META-INF/aop.xml</code> to give configuration to the weaver</li>
          </ul>
        </section>

        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Let's add monitoring to statsd &amp; Datadog to an Akka application</p>
          <img src="images/activatorapp.png"/>
        </section>
        
        <section data-background="images/production.jpg">
          <h2>War stories?</h2>
          <br/><br/>
          <p>What have we learnt in building the Reactive Monitor?</p>
          <p>&nbsp;</p>
          <p>What have we learnt in building a large Akka system?</p>
          <aside class="notes">
              Well, yes it is possible to Monitor too much, you need to be pragmatic over the metrics you want to record and you should always `sample`.  Nothing comes for free, the more you monitor the more data is sent over the wire the more computation that is performed.  

              But it is a nessarary evil, the visibility and the insight into the app montoring provides is invaluable in production.  

              So one of our clients hired us to write a large Akka system that could serve millions of requests a day, early on in the project we had enough functionlaity to start running some performance tests.

              Im sure this has happended to all of us at some point in the past, your first performance tests just sit there, not really taking hardware resource, essentially just "blocking". 
             
              We saw via the monitor mailbox queues growing, mean-time in 'onRecieve()' being too high. arrrrhhhhh...
          </aside>
        </section>

        <section data-background="images/production.jpg">
          <h2>Analysed the architecture</h2>
          <p>CPU-intensive (XML parsing)</p>
          <p>Non-reactive / blocking third-party libraries (DB drivers, ....)</p>
          <p>Reactive libraries (Async HTTP)</p>
          <aside class="notes">
              So we looked at the architecture, as in most big systems, we had a mixed bad of tech:
              CPU-intensive  - Churning through lots of Data, big XML files, Big Data problems
              Non-reactive - Legacy code, Blocking Libraries database integration etc...
              lots of Awesome Reactive stuff, Async Http, async db drivers all none blocking.
              and of cause then Actor system its self.  This all looked good, we had split the functional areas up into Actors or Sets of Actors all seemed nicely cohesive.  
              Then light bulb momment...
          </aside>
        </section>
        -->
      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
