<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Tuning Akka</title>
    <meta name="description" content="Tuning Akka">
    <meta name="author" content="Jan Machacek, Alex Lashford">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu%20Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-background="images/akkadays.jpg">
          <h1>Tuning Akka</h1>
          <h3>With a dose of idealism and realism</h3>
          <p>
            <small>
              Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a>&nbsp;&nbsp;|&nbsp;&nbsp;
              Alex Lashford <a href="https://twitter.com/alexlashford">@alexlashford</a>
            </small>
          </p>
        </section>

        <section data-background="images/success-baby.jpg">
          <h2>Congratulations! You've made it!</h2>
          <p>The users love your system - interactions increase </p>
          <p>100s &rarr; 1000s &rarr; 10,000s of users!</p>
          <p>And you <em>worry</em></p>
          <aside class="notes">
            <p>So Akka is 5 years old, it's a fantastic framework which gives us the toolset to create Scalable / Event Drivien applications.  Hopefully these applications will follow the core principles of the Reactice Manefesto, but what happens when you have created the next Netflix? Unfortunatly, Akka does not solve all of the woes of running in production, it is not a silver bullet, you still need to keep an eye on your stack and follow key principles during your development.</p>
            <p>In our talk we are going to run through some of the Basics of "Akka in Production" and hopefully give you some tips &amp; tricks as you embark on your Production journey.</p>
            <p>So the question is, are you ready for production?  We will revisit this question later but before we do, lets take a look at the basics.</p>
          </aside>
        </section>

        <section data-background="images/basics.jpg">
          <h2>The basics</h2>
          <ul>
            <li>Event-driven</li>
            <li>Scalable</li>
            <p></p>
          </ul>
          <aside class="notes">
            <p>You got the basics right. You are event-driven. Events (in Akka, think messages delivered to <code>ActorRef</code>s) are <em>not really inconvenient &amp; clunky method calls</em>, you treat them as truly asynchronous events that can arrive at any point, and your system must react to them.</p>
            <p>All this helps scalability. If one designs a system whose components are loosely-coupled and communicate throgh messages, it becomes easy to scale such system by simply adding processing nodes. The nodes could be CPU cores, JVMs, network nodes, sets of nodes in a different network region, ...</p>
            <p>You've spotted that these are the two reactive traits. Let's now explore what it takes to achieve the other two: resilient and responsive.</p>
          </aside>
        </section>

        <section data-background="images/basics.jpg">
          <h2>The basics</h2>
          <ul>
            <li>Your actors form hierarchies, and you have only a few top–level actors</li>
            <li>Defined supervisor strategies</li>
            <li>When creating actors, set the dispatcher, router and mailbox</li>
            <li>You do not allow actor's state to escape</li>
          </ul>
          <aside class="notes">
            <p>The top-level actors are not part of any supervision chain that you control. If the top-level actor fails, the entire system fails. In proper Akka system a parent actor creates and then supervises its children.</p>
            <p>You must have supervisor strategies, otherwise, you have no hope of being resilient. Of course, being resilient does not mean magically handling any exceptions. It means being able to get to a known and stable state after the error. </p>
            <p>The configuration for the actors (mailboxes, routers, dispatchers, ...) is configured in a well-known place. If the actor configuration needs some logic, have it all in code; if the configuration requires no logic at all, keep it in the configuration file. But do not mix the approaches. <code>system.actorOf(Props[FooActor])</code> is almost always bad.</p>
            <p>It is often tempting to send back a function that closes over the state as the response from an actor, but that is <em>always</em> a terrible idea. (Ignoring for now the problem of sending the closed-over variables and the function to some <em>remote</em> actor, this sort of horror immediately puts you back into the raw Java concurrency world.)</p>
          </aside>
        </section>

        <section data-background="images/tuning.jpg">
          <h2>Tune to achieve</h2>
          <p>You are <em>event-driven</em> and therefore more easily <em>scalable</em>. You are using Akka <em>properly</em>, so you just need to tweak some settings to achive the best <em>responsiveness</em> and <em>resilience</em>.</p>
          <aside class="notes">
            <p>Assuming your code follows our previous slides—that is:</p>
            <ul>
              <li>you have proper actor hierarchy, with supervisor strategies at the appropriate level giving resilience</li>
              <li>the <code>Props</code> for the actors always set the dispatcher, router, and mailbox</li>
              <li>you do not let [mutable] state escape</li>
            </ul>
            <p>Then your job is to ensure that you configure the dispatchers, routers and mailboxes appropriately for the type of load that your application is expected to handle.</p>
            <p>Even better, as we'll explore later on, you will instrument your application so that you <em>know</em> instead of <em>think</em> what your application is actually doing.</p>
          </aside>
        </section>

        <section data-background="images/tuning.jpg">
          <h2>Mailboxes, dispatchers and routers</h2>
          <ul>
            <li>Dispatchers execute arbitrary code</li>
            <li>Mailbox holds the messages for an actor</li>
            <li>Routers allow a number of actors to process the incoming messages</li>
          </ul>
          <aside class="notes">
            <p>In the Akka world, the dispatchers define the mailbox sharing strategy, and schedule the delivery of the messages between the actors. We have three dispatchers baked into Akka.</p>
            <ul>
              <li>[The default] Dispatcher sets each actor with its own mailbox; it is shareable amongst other actors; backed by thread pool or F-J pool. Optimised for non-blocking code.</li>
              <li>Pinned dispatcher sets each actor with its own mailbox; non-shareable amongst other actors—creates dedicated thread for each actor; backed by thread pool; optimised for blocking or CPU-bound operations</li>
              <li>Balancing dispatcher sets one mailbox for all actors; shareable only amongst actors of the same kind; backed by thead pool or F-J pool</li>
            </ul>
            <p>Mailbox holds the messages delivered to the actor. The dispatcher decides how actors share the mailbox, delivers the message to the mailbox, and schedules the actor's <code>receive</code> function. There are about 8 different type of mailboxes; the general theme is that mailboxes can be (bounded or unbounded (bad!)) and (arbitrary or prioritised) and (transitent or persistent). There's plenty of detail in the Akka documentation—the thing we'll mention here, and many more times in the talk, is that unbounded is BAD!</p>
            <p>Router manages and maintains its routees. The dispatcher delivers a message to the router, and depending on the routing strategy, it decides how to deliver it to one of its routees. The strategies are:</p>
            <ul>
              <li>Round robin router</li>
              <li>Random</li>
              <li>Smallest mailbox</li>
              <li>Broadcast</li>
              <li>Scatter, gather first completed</li>
            </ul>
            <p>Now that we understand what routers, mailboxes and dispatchers do, let's see how we choose the right one for a given problem.</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>Classes of problems</h2>
          <ul>
            <li>Number or string crunching</li>
            <li>I/O</li>
            <li>Memory</li>
          </ul>
          <aside class="notes">
            <p>So before you can make the right choices about configuration of the Actor system, you need to understand and classify the types of problems. Then ultimatly use the appropriate config to instruct Akka on how to best deal with that classifaction of problem.</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>Number or string crunching</h2>
          <ul>
            <li>Consumes the thread</li>
            <li>Avoid context switching</li>
            <li>Set the number of threads in the pool to match your cores</li>
          </ul>
          <aside class="notes">
            <p>This is typically CPU-bound work. There is no point in attempting to be somehow non-blocking: the CPU is be busy performing the computation, it cannot do the work in the background, and then send a message back when it's done.</p>
          	<p>Use the <code>PinnedDispatcher</code> backed by reasonably-sized thread pool. Remember CPU-bound work feels like blocking I/O; but it actually keeps the CPU hot. You want to avoid context switches, you want to keep the caches hot, prevent the CPU from entering sleep states, ...</p>
            <p>Unfortunately, there is no magical formula that you can apply to tune your thread pools on different platforms &amp; CPU architectures. So, what works on <code>c3.8xlarge</code> might not work just as well in the Rackspace cloud, not to mention Joyent. And that's assuming that we're on x86_64 CPUs. Throw in ARM, and the exact numbers change yet again.</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>I/O</h2>
          <ul>
            <li>Favour non-blocking APIs</li>
            <li>Be aware of back-pressure</li>
            <li>Carefully configure timeouts and remember to react to errors</li>
            <li>If you must use blocking calls, bulkhead them</li>
          </ul>
          <aside class="notes">
            <p>File, network and pipe traffic. Potentially blocking.</p>
            <p>Non-blocking APIs are not a golden hammer: you cannot just think "I'm using non-blocking APIs, therefore I'm safe". To be flippant, why do you think say a network interface comes with a silly specification like <em>1 Gbps</em>? It means that you should never feed it more than 1 Gbps. (And even that's just skimming the details, but let's not get too messy with kernel code and hardware.) With non-blocking APIs, you must be aware of the back-pressure.</p>
            <p>Back-pressure is a mechanism that allows the downstream components to drive the flow of data. The concept (in Reactive Streams) is that the downstream components must explicitly ask for more data from the upstrem components. </p>
            <p>If the downstream guys are feeling confident, they can easily request <code>Int.MaxValue</code> values, and then it's up to the upstream guys to satisfy the demand. 
            <br/>
            If the downstream components are super-cautious, they will only ask for one element at a time; and the upstream components must comply with the demand.</p>
            <p>If you are using non-blocking APIs appropriately (with back-pressure), be sure to configure and use appropriate timeouts and react to error conditions. Remember, the errors will come later, and [most likely] be delivered on a different thread. Same applies to timeouts: if your users are expecting a response in 2 seconds, it is useless to have 60 second timeout on some HTTP call that you're making to satisfy the user's request.</p>
            <p>Finally, if you are using blocking calls, be sure to separate them in threir own <code>Future</code>s, <code>Actor</code>s, or even <code>ActorSystem</code>s—ultimately—threads. Your actors <em>cannot</em> block, otherwise you are risking the health of the entire actor system.</p>
          </aside>
        </section>

        <section data-background="images/class.jpg">
          <h2>Memory</h2>
          <ul>
            <li>Use bounded mailboxes (<code>BoundedMailbox</code>, <code>BoundedPriorityMailbox</code>, <code>BoundedControlAwareMailbox</code>)</li>
            <li>If your actor behaviour is processing a lot of data, consider using off-heap structures (direct <code>ByteBuffer</code>s)</li>
            <li>Memory / GC pressure will make your application die with a whimper, not a bang</li>
          </ul>
          <aside class="notes">
            <p>Use bounded mailboxes - If your application generates too much pressure on the GC, the performance will degrade, but there is nothing you will be able to do about it. In extreme—or simply naive—cases, you can make your application appear completely frozen just by sending your actors too many messages.</p>
            <p>First off, and this applies to any production-ready Akka system, always use bounded mailboxes. If you do not, it is possible to kill your actor system by forcing an <code>OutOfMemoryError</code> or to generate so much GC pressure that the application will become completely unresponsive and spend all time in GC.</p>
            <p>If your actor is doing big data, it is much faster to allocate 2GiB off-heap, and then manage the memory layout yourself. Think some big-data analysis. Take a look at ByteBuffer api.</p>
            <p>in summary, Memory / GC pressure will make your application die with a whimper, not a bang.</p>
          </aside>
        </section>

        <section data-background="images/sinking_ship.jpg">
          <h2>Sometimes things aren't ideal</h2>
          <p><em>Your code</em> is reactive and tuned, reality brings things that are:</p>
          <ul>
            <li>not responsive</li>
            <li>not resilient</li>
            <li>not scalable</li>
          </ul>
          <aside class="notes">
            <p>Here, we mean integratation with libraries that block threads; that—once they fail, they keep failing; services that you know (or suspect) are not scalable.</p>
            <ul>
              <li>not responsive &rarr; bulkhead thread-pools and executors, identify and isolate</li>
              <li>not resilient &rarr; bulkhead failures, define good supervisor strategies</li>
              <li>not scalable &rarr; implement flow control / back pressure reporting or a hard circuit-breaker</li>
            </ul>
            <p>It would be nice to be able to make all of this reactive, but one needs to pick one's battles. And so, rather than trying to fix the world, an easier way is to isolate the problematic areas, and to <em>try to be nice</em> to services that cannot keep up with your system.</p>
            <p>Think how important the concept of <em>back pressure</em> is! It is far better for your system to know what its dependencies can cope with, than deal with sudden failures, or to have a hard circuit-breaker.</p>
          </aside>
        </section>

        <section data-background="images/sinking_ship.jpg">
          <h2>Bulkheading</h2>
          <p><em>Divide</em> your application not only by functional area, but by classifaction of the problem</p>
          <p>&nbsp;</p>
          <h2>Back-pressure</h2>
          <p>It is far better for your system to know what its dependencies can cope with, than to deal with the <em>big bang</em></p>
          <aside class="notes">
            <p>Two common themes we have touched on here is bulkheading &amp; back-pressure</p>
            <p>Bulkheading - This principle comes from ship building, where you would typically bulkhead (divide) parts of the hull. The aim to prevent the whole ship sinking due to damage in a single section of the hull. This idea is easily applied to the architecture of an Akka application. You need to isolate the CPU intensive and the blocking IO so not bring the whole application to a standstill.</p>
            <p>Back-pressure - It is far better for your system to know what its dependencies can cope with, than to deal with the <em>big bang!</em>, encapsulate the slowness and allow that function to self-regulate its consumption rate. Reactive streams (as implemented in Akka Streams, for example) provide non-blocking reporting and dealing with the back-pressure; on top of that Akka Streams provides a very convenient DSL to express the various transformation steps.</p>
          </aside>
        </section>

        <section data-background="images/notideal1.jpg">
          <h2><strike>Responsive</strike></h2>
          <ul>
            <li>The system does not react to the messages as soon as they arrive</li>
            <li>Blocking I/O</li>
            <li>Synchronisation</li>
          </ul>
          <p>Show solution &amp; tuning approach for the specific snippet</p>
          <p>Be asncyronous, real-time, open comms with the user.</p>
          <aside class="notes">
            <p>By <em>react to</em> we mean to send some response within the expected timeout. Even if the response is "I'm too busy" or "Slow down". At least the sender knows that this system is alive, it can deal with it. If the system sends no response (i.e. not responsive), then the sender cannot make any reasonable decisions.</p>
            <p>In blocking I/O all sorts of horrible things happen. You consume threads, which represent overhead for the kernel, but these threads are not doing anything useful. It's worse: the OS knows that the thread is blocked, and it may decide to put the CPU in a reduced-power state. Once the thread then wakes up (i.e. the data is available), everything (memory access) takes much longer. </p>
            <p>Second culprit is using synchronisation (notice the British spelling!—do not paste that into your IDE), which attempts to serialise parallel processes. In Akka, think <code>Await.ready</code> or <code>Await.result</code>. This is bad code. Futures zip together, one does not await.</p>
            <p>For the pointy-haired listeners, if you're not using the cloud machines to their full potential, you're wasting money!</p>
            <p>One other example from the battlefield: remember that number or string crunching can feel like blocking. In one of our systems, we found badly configured JAXB marshaller. We were needlessly creating and dropping its instances, which ate a lot of CPU time, and it made our system to be less responsive.</p>
            <p>Time in the <code>receive</code> handler increased, the number of available threads decresed.</p>
          </aside>
        </section>

        <section data-background="images/notideal2.jpg">
          <h2><strike>Resilient</strike></h2>
          <ul>
            <li>Failures start and then never stop</li>
            <li>Failures spread throughout the system</li>
          </ul>
          <aside class="notes">
            <p>Resilient means the ability to get to state you were in before the exception.</p>
            <p>Not resilient &rarr; cannot recover from an inconsistent state on its own.</p>
            <p>Library that once it gives exception, it always gives exception. I.e Hibernate session is danmaged, every subsiquent call will be broken too.</p>
            Here, a supervisor strategy will probably solve it, maybe re-initalise the the Hibernate session and restart the affected children.</p>
            <p>Although it could be worse. Maybe the error in the static initialisation block—it runs when the class is loaded into the JVM. Now, even a supervisor strategy cannot save you. (Unless you can do some magic with class loader). So, just propegate the error up. Kill the JVM. Which is fine, you are scalable, running multiple nodes, stateless. Everything should just work. If you are unsure, unleash the chaos army and see what happens.</p>
            <p>An example of failures spreading to other parts of the system is lazy marshalling, or say JPA. An actor can receive an instance of <code>User</code>, but when it calls its <code>roles</code> accessor, it throws <code>JpaException</code>. You can see that catching exceptions is not a solution, unless you have a pokemon handler. And that's no good, either. Supervise, restart and escalate depending on the problem.</p>
          </aside>
        </section>

        <section data-background="images/notideal3.png">
          <h2><strike>Scalable</strike></h2>
          <ul>
            <li>Cannot deal with the load you are putting on it</li>
            <li>Cannot report any back-pressure</li>
            <li>Costs money for extensive load</li>
          </ul>
          <aside class="notes">
            <p>You are relying on a component (think payment gateway) that you know (perhaps you signed a piece of paper) cannot scale. It is your responsibility to be nice to that component.</p>
            <p>You need to implement your own flow control, perhaps even a circuit-breaker. A flow control allow you to keep wihtin the component's limits, and to report back to your system if it is exceeding those limits. A circuit breaker is the big-red-button that can stop all requests reaching that component.</p>
            <p>Did we say you should have some sort of management API for your application? It could be as simple as another set of REST endpoints, or JMX mbeans.</p>
            <p>Akka (and Akka Streams) gives you the tools, you just have to be aware of what these tools are, and know the right situations to deploy them.</p>
          </aside>
        </section>   

        <!-- Monitoring -->
        <section data-background="images/everythingfine.jpg">
          <h2>So, tell me again</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>&nbsp;</h2>
          <h2>how everything's fine in production!</h2>
          <aside class="notes">
            <p>What is happening <em>inside</em> your application?</p>
            <p>we should be looking to lift the lid on our apps and shine the light on this Black box to get us some much needed visibility.</p>
            <ul>
              <li>Do we have any hotspots in our actor system?</li>
              <li>Are the message queues getting too big? (Are the messages spending too much time in the queues?) </li>
              <li>Is the 'mean' time in on-receive too high</li>
              <li>Do we have enough threads, and are those threads being blocked, utilised efficently?</li>
            </ul>
            <p>Monitoring gives an insight into the performance and flow of an application, allowing us see hotspots, and areas of poor performance: increasing our visibility to what is occuring. The aim is 24/7 uptime, preventing the big boom! How do you know that something's broken in time to do something about it? It is insufficient to monitor HTTP 500s, we want to have time to react before the 500s.</p>
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Monitor</h2>
          <p>Record <em>just enough</em> information. Too much slows down the monitored system, too little lets events go unnoticed.</p>
          <p>&nbsp;</p>
          <ul>
            <li>Actor creation &amp; destruction.</li>
            <li>Message types, message rates, failures and performance at the actor level</li>
            <li>Queue size at the (local) actor level</li>
            <li>The number of available and running threads in the <code>ThreadPool</code>s</li>
          </ul>
          <aside class="notes">
            <p>Do not allow the monitoring tool to bring down the application; use light-weight montioring message delivery mechanisms.</p>
          </aside>
        </section>

        <section data-background="images/monitor.jpg">
          <h2>Monitoring Options</h2>
          <ul>
            <li>Typesafe Console – development-focused montioring</li>
            <li>Reactive Monitor – lightweight, configurable, open source</li>
            <li>Kamon.io – lightweight, configurable, open source</li>
          </ul>
          <aside class="notes">
            <p>So for monitoring your akka application you have a few of options</p>
            <ul>
              <li>Typesafe Console - aimed at Development rather than prduction but can provide improved visibility for your devs.</li>
              <li>Reactive Monitor - Lightweight, configurable, muliple integrations, open source and improvements welcome.</li>
              <li>Kamon - Gaining populatrity, muliple integrations also Aspect based.</li>
            </ul>
          </aside>
        </section>

        <section data-background="images/mementomori.jpg">
          <h2>Remember!</h2>
          <ul>
            <li>Be reactive, isolate the non-reactive components</li>
            <li>Measure and then measure again, do not guess</li>
            <li>Find out how your application breaks under extreme load</li>
          </ul>
          <aside class="notes">
            <p><em>Finis coronat opus!</em>—the end crowns the work</p>
            <p>Remember: be event-driven, which helps scalability. Then ensure that you remain responsive through non-blocking APIs and bulkheading of blocking calls, take care of back-pressure and memory-pressure. Use your system's hierarchy: actors, entire JVMs, clusters of JVMs to provide reslience. It is better to go out with a bang (think <code>System.exit(-1)</code> than whimper along)</p>
            <p>Remember: The "Akka 101" applications don't provide production-ready configuration or style</p>
            <p>Remember: Good observation is good science. You want to come home and say to your partner that you've been <em>doing really complicated science all day at work</em>!</p>
          </aside>
        </section>

        <section data-background="images/devops.jpg">
          <h2>Thank you!</h2>
          <ul>
            <li>Slides at <a href="http://www.eigengo.com/tuning-akka">www.eigengo.com/tuning-akka</a><br/>
            <small>(Press s for speaker notes)</small></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a> | <a href="https://twitter.com/alexlashford">@alexlashford</a></li>
          </ul>
          <hr/>
          <p><big>Law of Murphy for devops: if thing can able go wrong, is mean is already wrong but you not have Nagios alert of it yet.</big></p>
        </section>
        
      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
