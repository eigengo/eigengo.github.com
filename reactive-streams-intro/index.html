<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Introducing Reactive Streams</title>
    <meta name="description" content="Introducing Reactive Streams (using Scala and Akka)">
    <meta name="author" content="Jan Machacek">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Introducing Reactive Streams</h1>
          <h3>The principles, patterns &amp; implementation</h3>
          <p>
            <small>Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a>&nbsp;&nbsp;|&nbsp;&nbsp;
            <a href="http://www.eigengo.com/reactive-streams-intro">www.eigengo.com/reactive-streams-intro</a></small>
          </p>
        </section>

        <section data-background="images/mumlava1.jpeg">
          <h2>Processing live data</h2>
          <ul>
            <li>Use all available processing power</li>
            <li>Fail gracefully</li>
            <li>Control the ingestion rate</li>
          </ul>
        </section>

        <section data-background="images/mumlava2.jpeg">
          <h2>We need to be</h2>
          <ul>
            <li><p>Responsive</p><p><small>Provide timely response, particularly in face of failures</small></p></li>
            <li><p>Resilient<p><small>To be stable—to reset to a working state after encountering a failure. Responsiveness to failures.</small></p></li>
            <li><p>Event-driven<p><small>Drive the application's behaviour as set of discrete events</small></p></li>
            <li><p>Scalable<p><small>To be able to handle spikes of usage and to be able to grow the application</small></p></li>
          </ul>
        </section>

        <section>
          <h2>Reactive Streams</h2>
          <p>The items from the manifesto</p>
        </section>

        <section>
          <h2>Asynchrony</h2>
          <p>Resilience demands that we acknowledge (and make the most of asynchronous behaviour). If we are to grow our application,
          we must build the foundations of resilience: encapsulation, isolation; and scalability: distribution across cores, nodes, regions, ...</p>
          <p>We don't want to closely couple our application: we break it into components that use events to talk amongst each other. The components do not know about each other. This gives us grounding for being able to distribute application. </p>
        </section>

        <section>
          <h2>Asynchronous boundaries</h2>
          <ul>
            <li>Between different applications. One does not simply call a method in another app!</li>
            <li>Between network regions and network nodes. Network is fundamentally asynchronous</li>
            <li>Between CPU sockets (cores). The link between sockets is remarkably similar to network</li>
            <li>Between threads</li>
            <li>Between actors (nota bene that actors can share threads, so they are a little smaller)</li>
          </ul>
        </section>

        <section>
          <h2>Data over the asynchronous boundary</h2>
          <p>Blocking calls. (BlockingQueue with—say—two threads.) The sender can get blocked when the receiver is too slow. But cannot react to cancel requests, cannot easily implement priorities. But also bad for CPUs: context switches, low-power states. After waking-up, everything is far more expensive. :((</p>
          <p>Push. Sender can always shove the data over, but the recepient can be overwhelmed. It can either buffer or drop =&gt; lossy or dangerous. :(</p>
          <p>Reactive. Non-blocking, non-dropping and bounded. :)</p>
        </section>

        <section>
          <h2>How to do that?</h2>
          <p>Lear from TCP. Match the rate of sending and receiving. Publisher (sender) sends the data, but the subscriber (receiver) signals back the rate it is expecting.</p>
          <p>Push when subscriber is faster</p>
          <p>Pull when ...</p>
          <p>Automatic switching between the modes</p>
          <p>Provisioning for batching. CPUs are good at repeating the same thing.</p>
        </section>

        <section>
          <h2>Data flows</h2>
          <p>Explicit definition of demand and supply streams.</p>
          <p>You can now have interesting components: say splitter and merger examples.</p>
        </section>

        <section>
          <h2>Akka Streams DSL</h2>
          <p>We attach <code>Consumer[A]</code> to <code>Producer[A]</code> using the <code>Flow</code> DSL. In the <code>Flow</code>,
          we:</p>
          <ul>
            <li>Filter elements (<code>drop</code>, <code>filter</code>),</li>
            <li>Transform elements (<code>map</code>, <code>mapConcat</code>, <code>fold</code>, <code>transform</code>),</li>
            <li>Group (<code>grouped</code>, <code>groupBy</code>),</li>
            <li>Append, zip and merge (<code>concat</code>, <code>zip</code>, <code>merge</code>),</li>
            <li>Finally, <em>materialize</em> the flow (<code>onComplete</code>, <code>consume</code>)</li>
          </ul>
        </section>

        <section>
          <h2>Materializing streams</h2>
          <p>Remember, the flow pipeline is not synchronous. Even though the code <em>feels</em> like it's chain of typesafe function calls, each step is responsive, resilient, event-driven and scalable, with back-presssure reporting.</p>
          <p><em>Materializing</em> the <code>Flow</code> is a way to turn the steps in the flow into reactive components. In Akka, we call these <code>Actor</code>s, and Akka's <code>FlowMaterializer</code> creates and wires-up the <code>Actor</code>s for the flow.</p>
        </section>

        <section>
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
Flow(...).
  filter(...).drop(...).
  map(...).mapConcat(...).fold(...).transform(...).
  grouped(...).groupBy(...).
  concat(...).zip(...).merge(...).
  
  onComplete(...).
  consume()
          </code></pre>
        </section>

        <section>
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
implicit val system = ActorSystem("Sys")
val source = Source.fromURI(...)
Flow(source.getLines()).
  foreach(println).
  consume(FlowMaterializer(MaterializerSettings()))
          </code></pre>
        </section>

        <section>
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
implicit val system = ActorSystem("Sys")
val source = Source.fromURI(...)
val materializer = FlowMaterializer(
                     MaterializerSettings())
Flow(source.getLines()).
  filter(_.length > 10).
  map(_.toUpperCase).
  foreach(println).
  consume(materializer)
          </code></pre>
        </section>

        <section>
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
implicit val system = ActorSystem("Sys")
val source = Source.fromURI(...)
val materializer = FlowMaterializer(
                     MaterializerSettings())
Flow(source.getLines()).
  filter(_.length > 10).
  map(_.toUpperCase).
  foreach(println).
  onComplete(materializer) {
    case Success(_) => system.shutdown()
    case Failure(e) =>
      println("Failure: " + e.getMessage)
      system.shutdown()
  }
          </code></pre>
        </section>

        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Application that reads the file <code>/20news-text.txt</code>, parses the lines, and attempts to predict which
          topic it apprears in, printing the prediction to standard output.</p>
          <p>We are using <a href="http://www.scalanlp.org/" target="_blank">ScalaNLP</a> to do the hard work.</p>
        </section>

        <section>
          <h2>Grouping</h2>
          <p>We'd like to report the total number of messages in each label. How many <code>alt.atheism</code>, how many <code>sci.space</code> and others.</p>
          <p>The result of <code>groupBy</code> is a tuple containing
          <ul>
            <li>the key value produced by the function supplied to <code>groupBy</code>,</li>
            <li>the <code>Producer[A]</code> of values with matching key</li>
          </ul>
          </p>
        </section>

        <section>
          <h2>Grouping</h2>
          <pre><code data-trim class="scala">
Flow(source.getLines()).
  mapConcat(l => List.fill(16)(Message.parse(l))).
  map(m => Classified(classifier.predict(m.text), m)).
  groupBy(_.label).
  foreach {
    case (label, producer) => ???
  }.
  onComplete(materializer) {
    case Success(_) => system.shutdown()
    case Failure(e) =>
      println("Failure: " + e.getMessage)
      system.shutdown()
}
          </code></pre>
        </section>

        <section>
          <h2>Grouping</h2>
          <pre><code data-trim class="scala">
Flow(source.getLines()).
  mapConcat(l => List.fill(16)(Message.parse(l))).
  map(m => Classified(classifier.predict(m.text), m)).
  groupBy(_.label).
  foreach {
    case (label, producer) =>
      Flow(producer).
        fold(0)((b, _) => b + 1).
        foreach(count => println(s"$label -> $count")).
        consume(materializer)
  }.
  onComplete(materializer) {
    case Success(_) => system.shutdown()
    case Failure(e) =>
      println("Failure: " + e.getMessage)
      system.shutdown()
}
          </code></pre>
        </section>

        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Application that reads the file <code>/20news-text.txt</code>, parses the lines, and attempts to predict which
          topic it apprears in, the number of messages in each topic.</p>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
