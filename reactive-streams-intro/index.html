<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Introducing Reactive Streams</title>
    <meta name="description" content="Introducing Reactive Streams (using Scala and Akka)">
    <meta name="author" content="Jan Machacek">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu Mono:regular,bold&subset=Latin">
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Introducing Reactive Streams</h1>
          <h3>The principles &amp; implementation</h3>
          <p>
            <small>Jan Macháček <a href="https://twitter.com/honzam399">@honzam399</a></small>
          </p>
        </section>

        <section data-background="images/mumlava1.jpeg">
          <h2>Processing live data</h2>
          <p>Incoming data rates are unpredictable &amp; uncontrollable</p>
          <ul>
            <li>Use all available processing power</li>
            <li>Be able to scale as required</li>
            <li>Recover from failures and errors</li>
            <li>Because <em>streams</em> are ephemeral data: one can never enter the same stream again!</li>
          </ul>
          <aside class="notes">
            Give examples of streaming applications: surveilance video, stock prices, engineering / monitoring events, ..., <em>yes, tweets</em>
          </aside>
        </section>

        <section data-background="images/mumlava2.jpeg">
          <h2>We need to be</h2>
          <ul>
            <li><p>Responsive</p><p><small>Provide timely response, particularly in face of failures</small></p></li>
            <li><p>Resilient<p><small>To be stable—to reset to a working state after encountering a failure. Responsiveness to failures.</small></p></li>
            <li><p>Event-driven<p><small>Drive the application's behaviour as set of discrete events</small></p></li>
            <li><p>Scalable<p><small>To be able to handle spikes of usage and to be able to grow the application</small></p></li>
          </ul>
          <aside class="notes">
            Reactive manifesto
          </aside>
        </section>

        <section data-background="images/mumlava1.jpeg">
          <h2>Reactive Streams</h2>
          <p>To successfully process live data streams, one must:</p>
          <ul>
            <li>Expose and acknowledge asynchronous nature</li>
            <li>Explicitly handle flow of data between the components</li>
          </ul>
          <aside class="notes">
            <p>Resilience demands that we acknowledge (and make the most of asynchronous behaviour). If we are to grow our application,
            we must build the foundations of resilience: encapsulation, isolation; and scalability: distribution across cores, nodes,  regions, ...</p>
            <p>We don't want to closely couple our application: we break it into components that use events to talk amongst each other. The components do not know about each other. This gives us grounding for being able to distribute application.</p>
          </aside>
        </section>

        <section data-background="images/onedoesnotsimply.png">
          <h2>One does not simply</h2>
          <ul>
            <li>Call a function in a different application</li>
            <li>Call a function in a (same) application on a different network node</li>
            <li>Push data at arbitrary rate down network interfaces</li>
            <li>Share data without cost between CPU sockets (cores)</li>
            <li>Share data between threads</li>
            <li>..</li>
          </ul>
          <aside class="notes">
            Explain that synchonous behaviour is often <em>emulated</em>, at great cost to the throughput of the system.
          </aside>
        </section>

        <section data-background="images/notreactive.jpg">
          <h2>Blocking calls</h2>
          <p>Say using <code>BlockingQueue[A]</code>s. The <em>producer</em> can become blocked when the <em>subscriber</em> is too slow. Moreover, it is difficult to:</p>
          <ul>
            <li>Keep the producer responsive (perhaps to receive <em>cancellations</em>)</li>
            <li>Correctly prioritise the incoming events</li>
            <li>Keep the context switches to a minimum</li>
            <li>Prevent the CPUs from entering low-power states</li>
          </ul>
        </section>

        <section data-background="images/notreactive.jpg">
          <h2>Pure push</h2>
          <p>The <em>producer</em> pushes the data to a queue, regardless of the subscribers' performance. And so, one runs into:</p>
          <ul>
            <li>Allocating too much memory if the queues are unbounded</li>
            <li>Dropping messages if they do not fit into a bounded queue</li>
          </ul>
          <aside class="notes">
            RxJava
          </aside>
        </section>

        <section data-background="images/reactive.jpg">
          <h2>Reactive</h2>
          <p>Responsive, resilient, event-driven and scalable. In our context, non-blocking, lossless and bounded.</p>
          <ul>
            <li>Publisher sends the data, subscriber signals when it is ready for more data</li>
            <li>Hybrid <em>push</em> / <em>pull</em> model</li>
            <li>Support but sensibly limit batching</li>
          </ul>
        </section>

<!--
        <section>
          <h2>Data flows</h2>
          <p>Explicit definition of demand and supply streams.</p>
          <p>You can now have interesting components: say splitter and merger examples.</p>
        </section>
-->

        <section data-background="images/blueprint.jpg">
          <h2>Main components</h2>
          <img src="images/overall.png"/>
        </section>

        <section data-background="images/blueprint.jpg">
          <h2>Publisher</h2>
          <pre><code data-trim class="scala">
trait Publisher[A] {
  def subscribe(subscriber: Subscriber[A]): Unit
}
          </code></pre>
        </section>

        <section data-background="images/blueprint.jpg">
          <h2>Subscriber</h2>
          <pre><code data-trim class="scala">
trait Subscriber[A] {
  def onSubscribe(subscription: Subscription): Unit
  
  def onNext(element: A): Unit
  
  def onComplete(): Unit
  
  def onError(cause: Throwable): Unit
}
          </code></pre>
        </section>

        <section data-background="images/blueprint.jpg">
          <h2>Subscription</h2>
          <pre><code data-trim class="scala">
trait Subscription {
  def cancel(): Unit
  
  def requestMore(elements: Int): Unit
}          
          </code></pre>
        </section>

        <section data-background="images/blueprint.jpg">
          <h2>Notice the <code>Unit</code>s</h2>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Akka Streams DSL</h2>
          <p>We attach <code>Subscriber[A]</code> to <code>Producer[A]</code> using the <code>Flow</code> DSL. In the <code>Flow</code>,
          we can transform the data from the <code>Producer[A]</code> by:</p>
          <ul>
            <li>Filtering elements (<code>drop</code>, <code>filter</code>)</li>
            <li>Transforming elements (<code>map</code>, <code>mapConcat</code>, <code>fold</code>, <code>transform</code>)</li>
            <li>Grouping (<code>grouped</code>, <code>groupBy</code>)</li>
            <li>Appending, ziping and merging (<code>concat</code>, <code>zip</code>, <code>merge</code>)</li>
            <li>Finally, <em>materialize</em> the flow (<code>onComplete</code>, <code>consume</code>)</li>
          </ul>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Materializing streams</h2>
          <p>Remember, the flow pipeline is not synchronous. Even though the code <em>feels</em> like it's chain of typesafe function calls, each step is responsive, resilient, event-driven and scalable, with back-presssure reporting.</p>
          <p><em>Materializing</em> the <code>Flow</code> is a way to turn the steps in the flow into reactive components. In Akka, we call these <code>Actor</code>s, and Akka's <code>FlowMaterializer</code> creates and wires-up the <code>Actor</code>s for the flow.</p>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
Flow(...).
  filter(...).drop(...).
  map(...).mapConcat(...).fold(...).transform(...).
  grouped(...).groupBy(...).
  concat(...).zip(...).merge(...).
  
  onComplete(...).
  consume()
          </code></pre>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
implicit val system = ActorSystem("Sys")
val source = Source.fromURI(...)
Flow(source.getLines()).
  foreach(println).
  consume(FlowMaterializer(MaterializerSettings()))
          </code></pre>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
implicit val system = ActorSystem("Sys")
val source = Source.fromURI(...)
val materializer = FlowMaterializer(
                     MaterializerSettings())
Flow(source.getLines()).
  filter(_.length > 10).
  map(_.toUpperCase).
  foreach(println).
  consume(materializer)
          </code></pre>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Code exmple</h2>
          <pre><code data-trim class="scala">
implicit val system = ActorSystem("Sys")
val source = Source.fromURI(...)
val materializer = FlowMaterializer(
                     MaterializerSettings())
Flow(source.getLines()).
  filter(_.length > 10).
  map(_.toUpperCase).
  foreach(println).
  onComplete(materializer) {
    case Success(_) => system.shutdown()
    case Failure(e) =>
      println("Failure: " + e.getMessage)
      system.shutdown()
  }
          </code></pre>
        </section>

        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Application that reads the file <code>/20news-text.txt</code>, parses the lines, and attempts to predict which
          topic it apprears in, printing the prediction to standard output.</p>
          <p>We are using <a href="http://www.scalanlp.org/" target="_blank">ScalaNLP</a> to do the hard work.</p>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Grouping</h2>
          <p>We'd like to report the total number of messages in each label. How many <code>alt.atheism</code>, how many <code>sci.space</code> and others.</p>
          <p>The result of <code>groupBy</code> is a tuple containing
          <ul>
            <li>the key value produced by the function supplied to <code>groupBy</code></li>
            <li>the <code>Producer[A]</code> of values with matching key</li>
          </ul>
          </p>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Grouping</h2>
          <pre><code data-trim class="scala">
Flow(source.getLines()).
  mapConcat(l => List.fill(16)(Message.parse(l))).
  map(m => Classified(classifier.predict(m.text), m)).
  groupBy(_.label).
  foreach {
    case (label, producer) => 
      // print(s"$label -> $count")
  }.
  onComplete(materializer) {
    case Success(_) => system.shutdown()
    case Failure(e) =>
      println("Failure: " + e.getMessage)
      system.shutdown()
  }
          </code></pre>
        </section>

        <section data-background="images/madderakka.jpg">
          <h2>Grouping</h2>
          <pre><code data-trim class="scala">
Flow(source.getLines()).
  mapConcat(l => List.fill(16)(Message.parse(l))).
  map(m => Classified(classifier.predict(m.text), m)).
  groupBy(_.label).
  foreach {
    case (label, producer) =>
      Flow(producer).
        fold(0)((b, _) => b + 1).
        foreach(count => println(s"$label -> $count")).
        consume(materializer)
  }.
  onComplete(materializer) {
    ...
  }
          </code></pre>
        </section>

        <section data-background="images/angrymob.jpg">
          <h1>Demo</h1>
          <p>Application that reads the file <code>/20news-text.txt</code>, parses the lines, and attempts to predict which
          topic it apprears in, the number of messages in each topic.</p>
        </section>

        <section>
          <h2>Thank you!</h2>
          <ul>
            <li>Source at <a href="https://github.com/eigengo/activator-breeze-streams">github.com/eigengo/activator-breeze-streams</a></li>
            <li>Slides at <a href="http://www.eigengo.com/reactive-streams-intro">www.eigengo.com/reactive-streams-intro</a></li>
            <li>Tweets at <a href="https://twitter.com/honzam399">@honzam399</a></li>
          </ul>
        </section>

      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: false,
        center: false,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
